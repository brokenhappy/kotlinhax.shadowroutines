// Klib ABI Dump
// Targets: [androidNativeArm32, androidNativeArm64, androidNativeX64, androidNativeX86, iosArm64, iosSimulatorArm64, iosX64, js, linuxArm64, linuxX64, macosArm64, macosX64, mingwX64, tvosArm64, tvosSimulatorArm64, tvosX64, wasmJs, wasmWasi, watchosArm32, watchosArm64, watchosDeviceArm64, watchosSimulatorArm64, watchosX64]
// Alias: native => [androidNativeArm32, androidNativeArm64, androidNativeX64, androidNativeX86, iosArm64, iosSimulatorArm64, iosX64, linuxArm64, linuxX64, macosArm64, macosX64, mingwX64, tvosArm64, tvosSimulatorArm64, tvosX64, watchosArm32, watchosArm64, watchosDeviceArm64, watchosSimulatorArm64, watchosX64]
// Rendering settings:
// - Signature version: 2
// - Show manifest properties: true
// - Show declarations: true

// Library unique name: <org.jetbrains.kotlinx:kotlinhax-shadowroutines-core>
open annotation class kotlinhax.shadowroutines/DelicateCoroutinesApi : kotlin/Annotation { // kotlinhax.shadowroutines/DelicateCoroutinesApi|null[0]
    constructor <init>() // kotlinhax.shadowroutines/DelicateCoroutinesApi.<init>|<init>(){}[0]
}

open annotation class kotlinhax.shadowroutines/ExperimentalCoroutinesApi : kotlin/Annotation { // kotlinhax.shadowroutines/ExperimentalCoroutinesApi|null[0]
    constructor <init>() // kotlinhax.shadowroutines/ExperimentalCoroutinesApi.<init>|<init>(){}[0]
}

open annotation class kotlinhax.shadowroutines/ExperimentalForInheritanceCoroutinesApi : kotlin/Annotation { // kotlinhax.shadowroutines/ExperimentalForInheritanceCoroutinesApi|null[0]
    constructor <init>() // kotlinhax.shadowroutines/ExperimentalForInheritanceCoroutinesApi.<init>|<init>(){}[0]
}

open annotation class kotlinhax.shadowroutines/FlowPreview : kotlin/Annotation { // kotlinhax.shadowroutines/FlowPreview|null[0]
    constructor <init>() // kotlinhax.shadowroutines/FlowPreview.<init>|<init>(){}[0]
}

open annotation class kotlinhax.shadowroutines/InternalCoroutinesApi : kotlin/Annotation { // kotlinhax.shadowroutines/InternalCoroutinesApi|null[0]
    constructor <init>() // kotlinhax.shadowroutines/InternalCoroutinesApi.<init>|<init>(){}[0]
}

open annotation class kotlinhax.shadowroutines/InternalForInheritanceCoroutinesApi : kotlin/Annotation { // kotlinhax.shadowroutines/InternalForInheritanceCoroutinesApi|null[0]
    constructor <init>() // kotlinhax.shadowroutines/InternalForInheritanceCoroutinesApi.<init>|<init>(){}[0]
}

open annotation class kotlinhax.shadowroutines/ObsoleteCoroutinesApi : kotlin/Annotation { // kotlinhax.shadowroutines/ObsoleteCoroutinesApi|null[0]
    constructor <init>() // kotlinhax.shadowroutines/ObsoleteCoroutinesApi.<init>|<init>(){}[0]
}

final enum class kotlinhax.shadowroutines.channels/BufferOverflow : kotlin/Enum<kotlinhax.shadowroutines.channels/BufferOverflow> { // kotlinhax.shadowroutines.channels/BufferOverflow|null[0]
    enum entry DROP_LATEST // kotlinhax.shadowroutines.channels/BufferOverflow.DROP_LATEST|null[0]
    enum entry DROP_OLDEST // kotlinhax.shadowroutines.channels/BufferOverflow.DROP_OLDEST|null[0]
    enum entry SUSPEND // kotlinhax.shadowroutines.channels/BufferOverflow.SUSPEND|null[0]

    final val entries // kotlinhax.shadowroutines.channels/BufferOverflow.entries|#static{}entries[0]
        final fun <get-entries>(): kotlin.enums/EnumEntries<kotlinhax.shadowroutines.channels/BufferOverflow> // kotlinhax.shadowroutines.channels/BufferOverflow.entries.<get-entries>|<get-entries>#static(){}[0]

    final fun valueOf(kotlin/String): kotlinhax.shadowroutines.channels/BufferOverflow // kotlinhax.shadowroutines.channels/BufferOverflow.valueOf|valueOf#static(kotlin.String){}[0]
    final fun values(): kotlin/Array<kotlinhax.shadowroutines.channels/BufferOverflow> // kotlinhax.shadowroutines.channels/BufferOverflow.values|values#static(){}[0]
}

final enum class kotlinhax.shadowroutines.flow/SharingCommand : kotlin/Enum<kotlinhax.shadowroutines.flow/SharingCommand> { // kotlinhax.shadowroutines.flow/SharingCommand|null[0]
    enum entry START // kotlinhax.shadowroutines.flow/SharingCommand.START|null[0]
    enum entry STOP // kotlinhax.shadowroutines.flow/SharingCommand.STOP|null[0]
    enum entry STOP_AND_RESET_REPLAY_CACHE // kotlinhax.shadowroutines.flow/SharingCommand.STOP_AND_RESET_REPLAY_CACHE|null[0]

    final val entries // kotlinhax.shadowroutines.flow/SharingCommand.entries|#static{}entries[0]
        final fun <get-entries>(): kotlin.enums/EnumEntries<kotlinhax.shadowroutines.flow/SharingCommand> // kotlinhax.shadowroutines.flow/SharingCommand.entries.<get-entries>|<get-entries>#static(){}[0]

    final fun valueOf(kotlin/String): kotlinhax.shadowroutines.flow/SharingCommand // kotlinhax.shadowroutines.flow/SharingCommand.valueOf|valueOf#static(kotlin.String){}[0]
    final fun values(): kotlin/Array<kotlinhax.shadowroutines.flow/SharingCommand> // kotlinhax.shadowroutines.flow/SharingCommand.values|values#static(){}[0]
}

final enum class kotlinhax.shadowroutines/CoroutineStart : kotlin/Enum<kotlinhax.shadowroutines/CoroutineStart> { // kotlinhax.shadowroutines/CoroutineStart|null[0]
    enum entry ATOMIC // kotlinhax.shadowroutines/CoroutineStart.ATOMIC|null[0]
    enum entry DEFAULT // kotlinhax.shadowroutines/CoroutineStart.DEFAULT|null[0]
    enum entry LAZY // kotlinhax.shadowroutines/CoroutineStart.LAZY|null[0]
    enum entry UNDISPATCHED // kotlinhax.shadowroutines/CoroutineStart.UNDISPATCHED|null[0]

    final val entries // kotlinhax.shadowroutines/CoroutineStart.entries|#static{}entries[0]
        final fun <get-entries>(): kotlin.enums/EnumEntries<kotlinhax.shadowroutines/CoroutineStart> // kotlinhax.shadowroutines/CoroutineStart.entries.<get-entries>|<get-entries>#static(){}[0]
    final val isLazy // kotlinhax.shadowroutines/CoroutineStart.isLazy|{}isLazy[0]
        final fun <get-isLazy>(): kotlin/Boolean // kotlinhax.shadowroutines/CoroutineStart.isLazy.<get-isLazy>|<get-isLazy>(){}[0]

    final fun <#A1: kotlin/Any?, #B1: kotlin/Any?> invoke(kotlin.coroutines/SuspendFunction1<#A1, #B1>, #A1, kotlin.coroutines/Continuation<#B1>) // kotlinhax.shadowroutines/CoroutineStart.invoke|invoke(kotlin.coroutines.SuspendFunction1<0:0,0:1>;0:0;kotlin.coroutines.Continuation<0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    final fun valueOf(kotlin/String): kotlinhax.shadowroutines/CoroutineStart // kotlinhax.shadowroutines/CoroutineStart.valueOf|valueOf#static(kotlin.String){}[0]
    final fun values(): kotlin/Array<kotlinhax.shadowroutines/CoroutineStart> // kotlinhax.shadowroutines/CoroutineStart.values|values#static(){}[0]
}

abstract fun interface <#A: in kotlin/Any?> kotlinhax.shadowroutines.flow/FlowCollector { // kotlinhax.shadowroutines.flow/FlowCollector|null[0]
    abstract suspend fun emit(#A) // kotlinhax.shadowroutines.flow/FlowCollector.emit|emit(1:0){}[0]
}

abstract fun interface kotlinhax.shadowroutines.flow/SharingStarted { // kotlinhax.shadowroutines.flow/SharingStarted|null[0]
    abstract fun command(kotlinhax.shadowroutines.flow/StateFlow<kotlin/Int>): kotlinhax.shadowroutines.flow/Flow<kotlinhax.shadowroutines.flow/SharingCommand> // kotlinhax.shadowroutines.flow/SharingStarted.command|command(kotlinhax.shadowroutines.flow.StateFlow<kotlin.Int>){}[0]

    final object Companion { // kotlinhax.shadowroutines.flow/SharingStarted.Companion|null[0]
        final val Eagerly // kotlinhax.shadowroutines.flow/SharingStarted.Companion.Eagerly|{}Eagerly[0]
            final fun <get-Eagerly>(): kotlinhax.shadowroutines.flow/SharingStarted // kotlinhax.shadowroutines.flow/SharingStarted.Companion.Eagerly.<get-Eagerly>|<get-Eagerly>(){}[0]
        final val Lazily // kotlinhax.shadowroutines.flow/SharingStarted.Companion.Lazily|{}Lazily[0]
            final fun <get-Lazily>(): kotlinhax.shadowroutines.flow/SharingStarted // kotlinhax.shadowroutines.flow/SharingStarted.Companion.Lazily.<get-Lazily>|<get-Lazily>(){}[0]

        final fun WhileSubscribed(kotlin/Long = ..., kotlin/Long = ...): kotlinhax.shadowroutines.flow/SharingStarted // kotlinhax.shadowroutines.flow/SharingStarted.Companion.WhileSubscribed|WhileSubscribed(kotlin.Long;kotlin.Long){}[0]
    }
}

abstract fun interface kotlinhax.shadowroutines/DisposableHandle { // kotlinhax.shadowroutines/DisposableHandle|null[0]
    abstract fun dispose() // kotlinhax.shadowroutines/DisposableHandle.dispose|dispose(){}[0]
}

abstract fun interface kotlinhax.shadowroutines/Runnable { // kotlinhax.shadowroutines/Runnable|null[0]
    abstract fun run() // kotlinhax.shadowroutines/Runnable.run|run(){}[0]
}

abstract interface <#A: in kotlin/Any?> kotlinhax.shadowroutines.channels/ProducerScope : kotlinhax.shadowroutines.channels/SendChannel<#A>, kotlinhax.shadowroutines/CoroutineScope { // kotlinhax.shadowroutines.channels/ProducerScope|null[0]
    abstract val channel // kotlinhax.shadowroutines.channels/ProducerScope.channel|{}channel[0]
        abstract fun <get-channel>(): kotlinhax.shadowroutines.channels/SendChannel<#A> // kotlinhax.shadowroutines.channels/ProducerScope.channel.<get-channel>|<get-channel>(){}[0]
}

abstract interface <#A: in kotlin/Any?> kotlinhax.shadowroutines.channels/SendChannel { // kotlinhax.shadowroutines.channels/SendChannel|null[0]
    abstract val isClosedForSend // kotlinhax.shadowroutines.channels/SendChannel.isClosedForSend|{}isClosedForSend[0]
        abstract fun <get-isClosedForSend>(): kotlin/Boolean // kotlinhax.shadowroutines.channels/SendChannel.isClosedForSend.<get-isClosedForSend>|<get-isClosedForSend>(){}[0]
    abstract val onSend // kotlinhax.shadowroutines.channels/SendChannel.onSend|{}onSend[0]
        abstract fun <get-onSend>(): kotlinhax.shadowroutines.selects/SelectClause2<#A, kotlinhax.shadowroutines.channels/SendChannel<#A>> // kotlinhax.shadowroutines.channels/SendChannel.onSend.<get-onSend>|<get-onSend>(){}[0]

    abstract fun close(kotlin/Throwable? = ...): kotlin/Boolean // kotlinhax.shadowroutines.channels/SendChannel.close|close(kotlin.Throwable?){}[0]
    abstract fun invokeOnClose(kotlin/Function1<kotlin/Throwable?, kotlin/Unit>) // kotlinhax.shadowroutines.channels/SendChannel.invokeOnClose|invokeOnClose(kotlin.Function1<kotlin.Throwable?,kotlin.Unit>){}[0]
    abstract fun trySend(#A): kotlinhax.shadowroutines.channels/ChannelResult<kotlin/Unit> // kotlinhax.shadowroutines.channels/SendChannel.trySend|trySend(1:0){}[0]
    abstract suspend fun send(#A) // kotlinhax.shadowroutines.channels/SendChannel.send|send(1:0){}[0]
    open fun offer(#A): kotlin/Boolean // kotlinhax.shadowroutines.channels/SendChannel.offer|offer(1:0){}[0]
}

abstract interface <#A: in kotlin/Any?> kotlinhax.shadowroutines/CancellableContinuation : kotlin.coroutines/Continuation<#A> { // kotlinhax.shadowroutines/CancellableContinuation|null[0]
    abstract val isActive // kotlinhax.shadowroutines/CancellableContinuation.isActive|{}isActive[0]
        abstract fun <get-isActive>(): kotlin/Boolean // kotlinhax.shadowroutines/CancellableContinuation.isActive.<get-isActive>|<get-isActive>(){}[0]
    abstract val isCancelled // kotlinhax.shadowroutines/CancellableContinuation.isCancelled|{}isCancelled[0]
        abstract fun <get-isCancelled>(): kotlin/Boolean // kotlinhax.shadowroutines/CancellableContinuation.isCancelled.<get-isCancelled>|<get-isCancelled>(){}[0]
    abstract val isCompleted // kotlinhax.shadowroutines/CancellableContinuation.isCompleted|{}isCompleted[0]
        abstract fun <get-isCompleted>(): kotlin/Boolean // kotlinhax.shadowroutines/CancellableContinuation.isCompleted.<get-isCompleted>|<get-isCompleted>(){}[0]

    abstract fun (kotlinhax.shadowroutines/CoroutineDispatcher).resumeUndispatched(#A) // kotlinhax.shadowroutines/CancellableContinuation.resumeUndispatched|resumeUndispatched@kotlinhax.shadowroutines.CoroutineDispatcher(1:0){}[0]
    abstract fun (kotlinhax.shadowroutines/CoroutineDispatcher).resumeUndispatchedWithException(kotlin/Throwable) // kotlinhax.shadowroutines/CancellableContinuation.resumeUndispatchedWithException|resumeUndispatchedWithException@kotlinhax.shadowroutines.CoroutineDispatcher(kotlin.Throwable){}[0]
    abstract fun <#A1: #A> resume(#A1, kotlin/Function3<kotlin/Throwable, #A1, kotlin.coroutines/CoroutineContext, kotlin/Unit>?) // kotlinhax.shadowroutines/CancellableContinuation.resume|resume(0:0;kotlin.Function3<kotlin.Throwable,0:0,kotlin.coroutines.CoroutineContext,kotlin.Unit>?){0§<1:0>}[0]
    abstract fun <#A1: #A> tryResume(#A1, kotlin/Any?, kotlin/Function3<kotlin/Throwable, #A1, kotlin.coroutines/CoroutineContext, kotlin/Unit>?): kotlin/Any? // kotlinhax.shadowroutines/CancellableContinuation.tryResume|tryResume(0:0;kotlin.Any?;kotlin.Function3<kotlin.Throwable,0:0,kotlin.coroutines.CoroutineContext,kotlin.Unit>?){0§<1:0>}[0]
    abstract fun cancel(kotlin/Throwable? = ...): kotlin/Boolean // kotlinhax.shadowroutines/CancellableContinuation.cancel|cancel(kotlin.Throwable?){}[0]
    abstract fun completeResume(kotlin/Any) // kotlinhax.shadowroutines/CancellableContinuation.completeResume|completeResume(kotlin.Any){}[0]
    abstract fun initCancellability() // kotlinhax.shadowroutines/CancellableContinuation.initCancellability|initCancellability(){}[0]
    abstract fun invokeOnCancellation(kotlin/Function1<kotlin/Throwable?, kotlin/Unit>) // kotlinhax.shadowroutines/CancellableContinuation.invokeOnCancellation|invokeOnCancellation(kotlin.Function1<kotlin.Throwable?,kotlin.Unit>){}[0]
    abstract fun resume(#A, kotlin/Function1<kotlin/Throwable, kotlin/Unit>?) // kotlinhax.shadowroutines/CancellableContinuation.resume|resume(1:0;kotlin.Function1<kotlin.Throwable,kotlin.Unit>?){}[0]
    abstract fun tryResume(#A, kotlin/Any? = ...): kotlin/Any? // kotlinhax.shadowroutines/CancellableContinuation.tryResume|tryResume(1:0;kotlin.Any?){}[0]
    abstract fun tryResumeWithException(kotlin/Throwable): kotlin/Any? // kotlinhax.shadowroutines/CancellableContinuation.tryResumeWithException|tryResumeWithException(kotlin.Throwable){}[0]
}

abstract interface <#A: kotlin/Any?> kotlinhax.shadowroutines.channels/BroadcastChannel : kotlinhax.shadowroutines.channels/SendChannel<#A> { // kotlinhax.shadowroutines.channels/BroadcastChannel|null[0]
    abstract fun cancel(kotlin.coroutines.cancellation/CancellationException? = ...) // kotlinhax.shadowroutines.channels/BroadcastChannel.cancel|cancel(kotlin.coroutines.cancellation.CancellationException?){}[0]
    abstract fun cancel(kotlin/Throwable? = ...): kotlin/Boolean // kotlinhax.shadowroutines.channels/BroadcastChannel.cancel|cancel(kotlin.Throwable?){}[0]
    abstract fun openSubscription(): kotlinhax.shadowroutines.channels/ReceiveChannel<#A> // kotlinhax.shadowroutines.channels/BroadcastChannel.openSubscription|openSubscription(){}[0]
}

abstract interface <#A: kotlin/Any?> kotlinhax.shadowroutines.channels/Channel : kotlinhax.shadowroutines.channels/ReceiveChannel<#A>, kotlinhax.shadowroutines.channels/SendChannel<#A> { // kotlinhax.shadowroutines.channels/Channel|null[0]
    final object Factory { // kotlinhax.shadowroutines.channels/Channel.Factory|null[0]
        final const val BUFFERED // kotlinhax.shadowroutines.channels/Channel.Factory.BUFFERED|{}BUFFERED[0]
            final fun <get-BUFFERED>(): kotlin/Int // kotlinhax.shadowroutines.channels/Channel.Factory.BUFFERED.<get-BUFFERED>|<get-BUFFERED>(){}[0]
        final const val CONFLATED // kotlinhax.shadowroutines.channels/Channel.Factory.CONFLATED|{}CONFLATED[0]
            final fun <get-CONFLATED>(): kotlin/Int // kotlinhax.shadowroutines.channels/Channel.Factory.CONFLATED.<get-CONFLATED>|<get-CONFLATED>(){}[0]
        final const val DEFAULT_BUFFER_PROPERTY_NAME // kotlinhax.shadowroutines.channels/Channel.Factory.DEFAULT_BUFFER_PROPERTY_NAME|{}DEFAULT_BUFFER_PROPERTY_NAME[0]
            final fun <get-DEFAULT_BUFFER_PROPERTY_NAME>(): kotlin/String // kotlinhax.shadowroutines.channels/Channel.Factory.DEFAULT_BUFFER_PROPERTY_NAME.<get-DEFAULT_BUFFER_PROPERTY_NAME>|<get-DEFAULT_BUFFER_PROPERTY_NAME>(){}[0]
        final const val RENDEZVOUS // kotlinhax.shadowroutines.channels/Channel.Factory.RENDEZVOUS|{}RENDEZVOUS[0]
            final fun <get-RENDEZVOUS>(): kotlin/Int // kotlinhax.shadowroutines.channels/Channel.Factory.RENDEZVOUS.<get-RENDEZVOUS>|<get-RENDEZVOUS>(){}[0]
        final const val UNLIMITED // kotlinhax.shadowroutines.channels/Channel.Factory.UNLIMITED|{}UNLIMITED[0]
            final fun <get-UNLIMITED>(): kotlin/Int // kotlinhax.shadowroutines.channels/Channel.Factory.UNLIMITED.<get-UNLIMITED>|<get-UNLIMITED>(){}[0]
    }
}

abstract interface <#A: kotlin/Any?> kotlinhax.shadowroutines.flow.internal/FusibleFlow : kotlinhax.shadowroutines.flow/Flow<#A> { // kotlinhax.shadowroutines.flow.internal/FusibleFlow|null[0]
    abstract fun fuse(kotlin.coroutines/CoroutineContext = ..., kotlin/Int = ..., kotlinhax.shadowroutines.channels/BufferOverflow = ...): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow.internal/FusibleFlow.fuse|fuse(kotlin.coroutines.CoroutineContext;kotlin.Int;kotlinhax.shadowroutines.channels.BufferOverflow){}[0]
}

abstract interface <#A: kotlin/Any?> kotlinhax.shadowroutines.flow/MutableSharedFlow : kotlinhax.shadowroutines.flow/FlowCollector<#A>, kotlinhax.shadowroutines.flow/SharedFlow<#A> { // kotlinhax.shadowroutines.flow/MutableSharedFlow|null[0]
    abstract val subscriptionCount // kotlinhax.shadowroutines.flow/MutableSharedFlow.subscriptionCount|{}subscriptionCount[0]
        abstract fun <get-subscriptionCount>(): kotlinhax.shadowroutines.flow/StateFlow<kotlin/Int> // kotlinhax.shadowroutines.flow/MutableSharedFlow.subscriptionCount.<get-subscriptionCount>|<get-subscriptionCount>(){}[0]

    abstract fun resetReplayCache() // kotlinhax.shadowroutines.flow/MutableSharedFlow.resetReplayCache|resetReplayCache(){}[0]
    abstract fun tryEmit(#A): kotlin/Boolean // kotlinhax.shadowroutines.flow/MutableSharedFlow.tryEmit|tryEmit(1:0){}[0]
    abstract suspend fun emit(#A) // kotlinhax.shadowroutines.flow/MutableSharedFlow.emit|emit(1:0){}[0]
}

abstract interface <#A: kotlin/Any?> kotlinhax.shadowroutines.flow/MutableStateFlow : kotlinhax.shadowroutines.flow/MutableSharedFlow<#A>, kotlinhax.shadowroutines.flow/StateFlow<#A> { // kotlinhax.shadowroutines.flow/MutableStateFlow|null[0]
    abstract var value // kotlinhax.shadowroutines.flow/MutableStateFlow.value|{}value[0]
        abstract fun <get-value>(): #A // kotlinhax.shadowroutines.flow/MutableStateFlow.value.<get-value>|<get-value>(){}[0]
        abstract fun <set-value>(#A) // kotlinhax.shadowroutines.flow/MutableStateFlow.value.<set-value>|<set-value>(1:0){}[0]

    abstract fun compareAndSet(#A, #A): kotlin/Boolean // kotlinhax.shadowroutines.flow/MutableStateFlow.compareAndSet|compareAndSet(1:0;1:0){}[0]
}

abstract interface <#A: kotlin/Any?> kotlinhax.shadowroutines/CompletableDeferred : kotlinhax.shadowroutines/Deferred<#A> { // kotlinhax.shadowroutines/CompletableDeferred|null[0]
    abstract fun complete(#A): kotlin/Boolean // kotlinhax.shadowroutines/CompletableDeferred.complete|complete(1:0){}[0]
    abstract fun completeExceptionally(kotlin/Throwable): kotlin/Boolean // kotlinhax.shadowroutines/CompletableDeferred.completeExceptionally|completeExceptionally(kotlin.Throwable){}[0]
}

abstract interface <#A: kotlin/Throwable & kotlinhax.shadowroutines/CopyableThrowable<#A>> kotlinhax.shadowroutines/CopyableThrowable { // kotlinhax.shadowroutines/CopyableThrowable|null[0]
    abstract fun createCopy(): #A? // kotlinhax.shadowroutines/CopyableThrowable.createCopy|createCopy(){}[0]
}

abstract interface <#A: out kotlin/Any?> kotlinhax.shadowroutines.channels/ChannelIterator { // kotlinhax.shadowroutines.channels/ChannelIterator|null[0]
    abstract fun next(): #A // kotlinhax.shadowroutines.channels/ChannelIterator.next|next(){}[0]
    abstract suspend fun hasNext(): kotlin/Boolean // kotlinhax.shadowroutines.channels/ChannelIterator.hasNext|hasNext(){}[0]
    open suspend fun next0(): #A // kotlinhax.shadowroutines.channels/ChannelIterator.next0|next0(){}[0]
}

abstract interface <#A: out kotlin/Any?> kotlinhax.shadowroutines.channels/ReceiveChannel { // kotlinhax.shadowroutines.channels/ReceiveChannel|null[0]
    abstract val isClosedForReceive // kotlinhax.shadowroutines.channels/ReceiveChannel.isClosedForReceive|{}isClosedForReceive[0]
        abstract fun <get-isClosedForReceive>(): kotlin/Boolean // kotlinhax.shadowroutines.channels/ReceiveChannel.isClosedForReceive.<get-isClosedForReceive>|<get-isClosedForReceive>(){}[0]
    abstract val isEmpty // kotlinhax.shadowroutines.channels/ReceiveChannel.isEmpty|{}isEmpty[0]
        abstract fun <get-isEmpty>(): kotlin/Boolean // kotlinhax.shadowroutines.channels/ReceiveChannel.isEmpty.<get-isEmpty>|<get-isEmpty>(){}[0]
    abstract val onReceive // kotlinhax.shadowroutines.channels/ReceiveChannel.onReceive|{}onReceive[0]
        abstract fun <get-onReceive>(): kotlinhax.shadowroutines.selects/SelectClause1<#A> // kotlinhax.shadowroutines.channels/ReceiveChannel.onReceive.<get-onReceive>|<get-onReceive>(){}[0]
    abstract val onReceiveCatching // kotlinhax.shadowroutines.channels/ReceiveChannel.onReceiveCatching|{}onReceiveCatching[0]
        abstract fun <get-onReceiveCatching>(): kotlinhax.shadowroutines.selects/SelectClause1<kotlinhax.shadowroutines.channels/ChannelResult<#A>> // kotlinhax.shadowroutines.channels/ReceiveChannel.onReceiveCatching.<get-onReceiveCatching>|<get-onReceiveCatching>(){}[0]
    open val onReceiveOrNull // kotlinhax.shadowroutines.channels/ReceiveChannel.onReceiveOrNull|{}onReceiveOrNull[0]
        open fun <get-onReceiveOrNull>(): kotlinhax.shadowroutines.selects/SelectClause1<#A?> // kotlinhax.shadowroutines.channels/ReceiveChannel.onReceiveOrNull.<get-onReceiveOrNull>|<get-onReceiveOrNull>(){}[0]

    abstract fun cancel(kotlin.coroutines.cancellation/CancellationException? = ...) // kotlinhax.shadowroutines.channels/ReceiveChannel.cancel|cancel(kotlin.coroutines.cancellation.CancellationException?){}[0]
    abstract fun cancel(kotlin/Throwable? = ...): kotlin/Boolean // kotlinhax.shadowroutines.channels/ReceiveChannel.cancel|cancel(kotlin.Throwable?){}[0]
    abstract fun iterator(): kotlinhax.shadowroutines.channels/ChannelIterator<#A> // kotlinhax.shadowroutines.channels/ReceiveChannel.iterator|iterator(){}[0]
    abstract fun tryReceive(): kotlinhax.shadowroutines.channels/ChannelResult<#A> // kotlinhax.shadowroutines.channels/ReceiveChannel.tryReceive|tryReceive(){}[0]
    abstract suspend fun receive(): #A // kotlinhax.shadowroutines.channels/ReceiveChannel.receive|receive(){}[0]
    abstract suspend fun receiveCatching(): kotlinhax.shadowroutines.channels/ChannelResult<#A> // kotlinhax.shadowroutines.channels/ReceiveChannel.receiveCatching|receiveCatching(){}[0]
    open fun cancel() // kotlinhax.shadowroutines.channels/ReceiveChannel.cancel|cancel(){}[0]
    open fun poll(): #A? // kotlinhax.shadowroutines.channels/ReceiveChannel.poll|poll(){}[0]
    open suspend fun receiveOrNull(): #A? // kotlinhax.shadowroutines.channels/ReceiveChannel.receiveOrNull|receiveOrNull(){}[0]
}

abstract interface <#A: out kotlin/Any?> kotlinhax.shadowroutines.flow/Flow { // kotlinhax.shadowroutines.flow/Flow|null[0]
    abstract suspend fun collect(kotlinhax.shadowroutines.flow/FlowCollector<#A>) // kotlinhax.shadowroutines.flow/Flow.collect|collect(kotlinhax.shadowroutines.flow.FlowCollector<1:0>){}[0]
}

abstract interface <#A: out kotlin/Any?> kotlinhax.shadowroutines.flow/SharedFlow : kotlinhax.shadowroutines.flow/Flow<#A> { // kotlinhax.shadowroutines.flow/SharedFlow|null[0]
    abstract val replayCache // kotlinhax.shadowroutines.flow/SharedFlow.replayCache|{}replayCache[0]
        abstract fun <get-replayCache>(): kotlin.collections/List<#A> // kotlinhax.shadowroutines.flow/SharedFlow.replayCache.<get-replayCache>|<get-replayCache>(){}[0]

    abstract suspend fun collect(kotlinhax.shadowroutines.flow/FlowCollector<#A>): kotlin/Nothing // kotlinhax.shadowroutines.flow/SharedFlow.collect|collect(kotlinhax.shadowroutines.flow.FlowCollector<1:0>){}[0]
}

abstract interface <#A: out kotlin/Any?> kotlinhax.shadowroutines.flow/StateFlow : kotlinhax.shadowroutines.flow/SharedFlow<#A> { // kotlinhax.shadowroutines.flow/StateFlow|null[0]
    abstract val value // kotlinhax.shadowroutines.flow/StateFlow.value|{}value[0]
        abstract fun <get-value>(): #A // kotlinhax.shadowroutines.flow/StateFlow.value.<get-value>|<get-value>(){}[0]
}

abstract interface <#A: out kotlin/Any?> kotlinhax.shadowroutines/Deferred : kotlinhax.shadowroutines/Job { // kotlinhax.shadowroutines/Deferred|null[0]
    abstract val onAwait // kotlinhax.shadowroutines/Deferred.onAwait|{}onAwait[0]
        abstract fun <get-onAwait>(): kotlinhax.shadowroutines.selects/SelectClause1<#A> // kotlinhax.shadowroutines/Deferred.onAwait.<get-onAwait>|<get-onAwait>(){}[0]

    abstract fun getCompleted(): #A // kotlinhax.shadowroutines/Deferred.getCompleted|getCompleted(){}[0]
    abstract fun getCompletionExceptionOrNull(): kotlin/Throwable? // kotlinhax.shadowroutines/Deferred.getCompletionExceptionOrNull|getCompletionExceptionOrNull(){}[0]
    abstract suspend fun await(): #A // kotlinhax.shadowroutines/Deferred.await|await(){}[0]
}

abstract interface kotlinhax.shadowroutines.sync/Mutex { // kotlinhax.shadowroutines.sync/Mutex|null[0]
    abstract val isLocked // kotlinhax.shadowroutines.sync/Mutex.isLocked|{}isLocked[0]
        abstract fun <get-isLocked>(): kotlin/Boolean // kotlinhax.shadowroutines.sync/Mutex.isLocked.<get-isLocked>|<get-isLocked>(){}[0]
    abstract val onLock // kotlinhax.shadowroutines.sync/Mutex.onLock|{}onLock[0]
        abstract fun <get-onLock>(): kotlinhax.shadowroutines.selects/SelectClause2<kotlin/Any?, kotlinhax.shadowroutines.sync/Mutex> // kotlinhax.shadowroutines.sync/Mutex.onLock.<get-onLock>|<get-onLock>(){}[0]

    abstract fun holdsLock(kotlin/Any): kotlin/Boolean // kotlinhax.shadowroutines.sync/Mutex.holdsLock|holdsLock(kotlin.Any){}[0]
    abstract fun tryLock(kotlin/Any? = ...): kotlin/Boolean // kotlinhax.shadowroutines.sync/Mutex.tryLock|tryLock(kotlin.Any?){}[0]
    abstract fun unlock(kotlin/Any? = ...) // kotlinhax.shadowroutines.sync/Mutex.unlock|unlock(kotlin.Any?){}[0]
    abstract suspend fun lock(kotlin/Any? = ...) // kotlinhax.shadowroutines.sync/Mutex.lock|lock(kotlin.Any?){}[0]
}

abstract interface kotlinhax.shadowroutines.sync/Semaphore { // kotlinhax.shadowroutines.sync/Semaphore|null[0]
    abstract val availablePermits // kotlinhax.shadowroutines.sync/Semaphore.availablePermits|{}availablePermits[0]
        abstract fun <get-availablePermits>(): kotlin/Int // kotlinhax.shadowroutines.sync/Semaphore.availablePermits.<get-availablePermits>|<get-availablePermits>(){}[0]

    abstract fun release() // kotlinhax.shadowroutines.sync/Semaphore.release|release(){}[0]
    abstract fun tryAcquire(): kotlin/Boolean // kotlinhax.shadowroutines.sync/Semaphore.tryAcquire|tryAcquire(){}[0]
    abstract suspend fun acquire() // kotlinhax.shadowroutines.sync/Semaphore.acquire|acquire(){}[0]
}

abstract interface kotlinhax.shadowroutines/ChildHandle : kotlinhax.shadowroutines/DisposableHandle { // kotlinhax.shadowroutines/ChildHandle|null[0]
    abstract val parent // kotlinhax.shadowroutines/ChildHandle.parent|{}parent[0]
        abstract fun <get-parent>(): kotlinhax.shadowroutines/Job? // kotlinhax.shadowroutines/ChildHandle.parent.<get-parent>|<get-parent>(){}[0]

    abstract fun childCancelled(kotlin/Throwable): kotlin/Boolean // kotlinhax.shadowroutines/ChildHandle.childCancelled|childCancelled(kotlin.Throwable){}[0]
}

abstract interface kotlinhax.shadowroutines/ChildJob : kotlinhax.shadowroutines/Job { // kotlinhax.shadowroutines/ChildJob|null[0]
    abstract fun parentCancelled(kotlinhax.shadowroutines/ParentJob) // kotlinhax.shadowroutines/ChildJob.parentCancelled|parentCancelled(kotlinhax.shadowroutines.ParentJob){}[0]
}

abstract interface kotlinhax.shadowroutines/CompletableJob : kotlinhax.shadowroutines/Job { // kotlinhax.shadowroutines/CompletableJob|null[0]
    abstract fun complete(): kotlin/Boolean // kotlinhax.shadowroutines/CompletableJob.complete|complete(){}[0]
    abstract fun completeExceptionally(kotlin/Throwable): kotlin/Boolean // kotlinhax.shadowroutines/CompletableJob.completeExceptionally|completeExceptionally(kotlin.Throwable){}[0]
}

abstract interface kotlinhax.shadowroutines/CoroutineExceptionHandler : kotlin.coroutines/CoroutineContext.Element { // kotlinhax.shadowroutines/CoroutineExceptionHandler|null[0]
    abstract fun handleException(kotlin.coroutines/CoroutineContext, kotlin/Throwable) // kotlinhax.shadowroutines/CoroutineExceptionHandler.handleException|handleException(kotlin.coroutines.CoroutineContext;kotlin.Throwable){}[0]

    final object Key : kotlin.coroutines/CoroutineContext.Key<kotlinhax.shadowroutines/CoroutineExceptionHandler> // kotlinhax.shadowroutines/CoroutineExceptionHandler.Key|null[0]
}

abstract interface kotlinhax.shadowroutines/CoroutineScope { // kotlinhax.shadowroutines/CoroutineScope|null[0]
    abstract val coroutineContext // kotlinhax.shadowroutines/CoroutineScope.coroutineContext|{}coroutineContext[0]
        abstract fun <get-coroutineContext>(): kotlin.coroutines/CoroutineContext // kotlinhax.shadowroutines/CoroutineScope.coroutineContext.<get-coroutineContext>|<get-coroutineContext>(){}[0]
}

abstract interface kotlinhax.shadowroutines/Delay { // kotlinhax.shadowroutines/Delay|null[0]
    abstract fun scheduleResumeAfterDelay(kotlin/Long, kotlinhax.shadowroutines/CancellableContinuation<kotlin/Unit>) // kotlinhax.shadowroutines/Delay.scheduleResumeAfterDelay|scheduleResumeAfterDelay(kotlin.Long;kotlinhax.shadowroutines.CancellableContinuation<kotlin.Unit>){}[0]
    open fun invokeOnTimeout(kotlin/Long, kotlinhax.shadowroutines/Runnable, kotlin.coroutines/CoroutineContext): kotlinhax.shadowroutines/DisposableHandle // kotlinhax.shadowroutines/Delay.invokeOnTimeout|invokeOnTimeout(kotlin.Long;kotlinhax.shadowroutines.Runnable;kotlin.coroutines.CoroutineContext){}[0]
    open suspend fun delay(kotlin/Long) // kotlinhax.shadowroutines/Delay.delay|delay(kotlin.Long){}[0]
}

abstract interface kotlinhax.shadowroutines/Job : kotlin.coroutines/CoroutineContext.Element { // kotlinhax.shadowroutines/Job|null[0]
    abstract val children // kotlinhax.shadowroutines/Job.children|{}children[0]
        abstract fun <get-children>(): kotlin.sequences/Sequence<kotlinhax.shadowroutines/Job> // kotlinhax.shadowroutines/Job.children.<get-children>|<get-children>(){}[0]
    abstract val isActive // kotlinhax.shadowroutines/Job.isActive|{}isActive[0]
        abstract fun <get-isActive>(): kotlin/Boolean // kotlinhax.shadowroutines/Job.isActive.<get-isActive>|<get-isActive>(){}[0]
    abstract val isCancelled // kotlinhax.shadowroutines/Job.isCancelled|{}isCancelled[0]
        abstract fun <get-isCancelled>(): kotlin/Boolean // kotlinhax.shadowroutines/Job.isCancelled.<get-isCancelled>|<get-isCancelled>(){}[0]
    abstract val isCompleted // kotlinhax.shadowroutines/Job.isCompleted|{}isCompleted[0]
        abstract fun <get-isCompleted>(): kotlin/Boolean // kotlinhax.shadowroutines/Job.isCompleted.<get-isCompleted>|<get-isCompleted>(){}[0]
    abstract val onJoin // kotlinhax.shadowroutines/Job.onJoin|{}onJoin[0]
        abstract fun <get-onJoin>(): kotlinhax.shadowroutines.selects/SelectClause0 // kotlinhax.shadowroutines/Job.onJoin.<get-onJoin>|<get-onJoin>(){}[0]
    abstract val parent // kotlinhax.shadowroutines/Job.parent|{}parent[0]
        abstract fun <get-parent>(): kotlinhax.shadowroutines/Job? // kotlinhax.shadowroutines/Job.parent.<get-parent>|<get-parent>(){}[0]

    abstract fun attachChild(kotlinhax.shadowroutines/ChildJob): kotlinhax.shadowroutines/ChildHandle // kotlinhax.shadowroutines/Job.attachChild|attachChild(kotlinhax.shadowroutines.ChildJob){}[0]
    abstract fun cancel(kotlin.coroutines.cancellation/CancellationException? = ...) // kotlinhax.shadowroutines/Job.cancel|cancel(kotlin.coroutines.cancellation.CancellationException?){}[0]
    abstract fun cancel(kotlin/Throwable? = ...): kotlin/Boolean // kotlinhax.shadowroutines/Job.cancel|cancel(kotlin.Throwable?){}[0]
    abstract fun getCancellationException(): kotlin.coroutines.cancellation/CancellationException // kotlinhax.shadowroutines/Job.getCancellationException|getCancellationException(){}[0]
    abstract fun invokeOnCompletion(kotlin/Boolean = ..., kotlin/Boolean = ..., kotlin/Function1<kotlin/Throwable?, kotlin/Unit>): kotlinhax.shadowroutines/DisposableHandle // kotlinhax.shadowroutines/Job.invokeOnCompletion|invokeOnCompletion(kotlin.Boolean;kotlin.Boolean;kotlin.Function1<kotlin.Throwable?,kotlin.Unit>){}[0]
    abstract fun invokeOnCompletion(kotlin/Function1<kotlin/Throwable?, kotlin/Unit>): kotlinhax.shadowroutines/DisposableHandle // kotlinhax.shadowroutines/Job.invokeOnCompletion|invokeOnCompletion(kotlin.Function1<kotlin.Throwable?,kotlin.Unit>){}[0]
    abstract fun start(): kotlin/Boolean // kotlinhax.shadowroutines/Job.start|start(){}[0]
    abstract suspend fun join() // kotlinhax.shadowroutines/Job.join|join(){}[0]
    open fun cancel() // kotlinhax.shadowroutines/Job.cancel|cancel(){}[0]
    open fun plus(kotlinhax.shadowroutines/Job): kotlinhax.shadowroutines/Job // kotlinhax.shadowroutines/Job.plus|plus(kotlinhax.shadowroutines.Job){}[0]

    final object Key : kotlin.coroutines/CoroutineContext.Key<kotlinhax.shadowroutines/Job> // kotlinhax.shadowroutines/Job.Key|null[0]
}

abstract interface kotlinhax.shadowroutines/ParentJob : kotlinhax.shadowroutines/Job { // kotlinhax.shadowroutines/ParentJob|null[0]
    abstract fun getChildJobCancellationCause(): kotlin.coroutines.cancellation/CancellationException // kotlinhax.shadowroutines/ParentJob.getChildJobCancellationCause|getChildJobCancellationCause(){}[0]
}

sealed interface <#A: in kotlin/Any?, #B: out kotlin/Any?> kotlinhax.shadowroutines.selects/SelectClause2 : kotlinhax.shadowroutines.selects/SelectClause // kotlinhax.shadowroutines.selects/SelectClause2|null[0]

sealed interface <#A: in kotlin/Any?> kotlinhax.shadowroutines.selects/SelectBuilder { // kotlinhax.shadowroutines.selects/SelectBuilder|null[0]
    abstract fun (kotlinhax.shadowroutines.selects/SelectClause0).invoke(kotlin.coroutines/SuspendFunction0<#A>) // kotlinhax.shadowroutines.selects/SelectBuilder.invoke|invoke@kotlinhax.shadowroutines.selects.SelectClause0(kotlin.coroutines.SuspendFunction0<1:0>){}[0]
    abstract fun <#A1: kotlin/Any?, #B1: kotlin/Any?> (kotlinhax.shadowroutines.selects/SelectClause2<#A1, #B1>).invoke(#A1, kotlin.coroutines/SuspendFunction1<#B1, #A>) // kotlinhax.shadowroutines.selects/SelectBuilder.invoke|invoke@kotlinhax.shadowroutines.selects.SelectClause2<0:0,0:1>(0:0;kotlin.coroutines.SuspendFunction1<0:1,1:0>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    abstract fun <#A1: kotlin/Any?> (kotlinhax.shadowroutines.selects/SelectClause1<#A1>).invoke(kotlin.coroutines/SuspendFunction1<#A1, #A>) // kotlinhax.shadowroutines.selects/SelectBuilder.invoke|invoke@kotlinhax.shadowroutines.selects.SelectClause1<0:0>(kotlin.coroutines.SuspendFunction1<0:0,1:0>){0§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> (kotlinhax.shadowroutines.selects/SelectClause2<#A1?, #B1>).invoke(kotlin.coroutines/SuspendFunction1<#B1, #A>) // kotlinhax.shadowroutines.selects/SelectBuilder.invoke|invoke@kotlinhax.shadowroutines.selects.SelectClause2<0:0?,0:1>(kotlin.coroutines.SuspendFunction1<0:1,1:0>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun onTimeout(kotlin/Long, kotlin.coroutines/SuspendFunction0<#A>) // kotlinhax.shadowroutines.selects/SelectBuilder.onTimeout|onTimeout(kotlin.Long;kotlin.coroutines.SuspendFunction0<1:0>){}[0]
}

sealed interface <#A: in kotlin/Any?> kotlinhax.shadowroutines.selects/SelectInstance { // kotlinhax.shadowroutines.selects/SelectInstance|null[0]
    abstract val context // kotlinhax.shadowroutines.selects/SelectInstance.context|{}context[0]
        abstract fun <get-context>(): kotlin.coroutines/CoroutineContext // kotlinhax.shadowroutines.selects/SelectInstance.context.<get-context>|<get-context>(){}[0]

    abstract fun disposeOnCompletion(kotlinhax.shadowroutines/DisposableHandle) // kotlinhax.shadowroutines.selects/SelectInstance.disposeOnCompletion|disposeOnCompletion(kotlinhax.shadowroutines.DisposableHandle){}[0]
    abstract fun selectInRegistrationPhase(kotlin/Any?) // kotlinhax.shadowroutines.selects/SelectInstance.selectInRegistrationPhase|selectInRegistrationPhase(kotlin.Any?){}[0]
    abstract fun trySelect(kotlin/Any, kotlin/Any?): kotlin/Boolean // kotlinhax.shadowroutines.selects/SelectInstance.trySelect|trySelect(kotlin.Any;kotlin.Any?){}[0]
}

sealed interface <#A: out kotlin/Any?> kotlinhax.shadowroutines.selects/SelectClause1 : kotlinhax.shadowroutines.selects/SelectClause // kotlinhax.shadowroutines.selects/SelectClause1|null[0]

sealed interface kotlinhax.shadowroutines.selects/SelectClause { // kotlinhax.shadowroutines.selects/SelectClause|null[0]
    abstract val clauseObject // kotlinhax.shadowroutines.selects/SelectClause.clauseObject|{}clauseObject[0]
        abstract fun <get-clauseObject>(): kotlin/Any // kotlinhax.shadowroutines.selects/SelectClause.clauseObject.<get-clauseObject>|<get-clauseObject>(){}[0]
    abstract val onCancellationConstructor // kotlinhax.shadowroutines.selects/SelectClause.onCancellationConstructor|{}onCancellationConstructor[0]
        abstract fun <get-onCancellationConstructor>(): kotlin/Function3<kotlinhax.shadowroutines.selects/SelectInstance<*>, kotlin/Any?, kotlin/Any?, kotlin/Function3<kotlin/Throwable, kotlin/Any?, kotlin.coroutines/CoroutineContext, kotlin/Unit>>? // kotlinhax.shadowroutines.selects/SelectClause.onCancellationConstructor.<get-onCancellationConstructor>|<get-onCancellationConstructor>(){}[0]
    abstract val processResFunc // kotlinhax.shadowroutines.selects/SelectClause.processResFunc|{}processResFunc[0]
        abstract fun <get-processResFunc>(): kotlin/Function3<kotlin/Any, kotlin/Any?, kotlin/Any?, kotlin/Any?> // kotlinhax.shadowroutines.selects/SelectClause.processResFunc.<get-processResFunc>|<get-processResFunc>(){}[0]
    abstract val regFunc // kotlinhax.shadowroutines.selects/SelectClause.regFunc|{}regFunc[0]
        abstract fun <get-regFunc>(): kotlin/Function3<kotlin/Any, kotlinhax.shadowroutines.selects/SelectInstance<*>, kotlin/Any?, kotlin/Unit> // kotlinhax.shadowroutines.selects/SelectClause.regFunc.<get-regFunc>|<get-regFunc>(){}[0]
}

sealed interface kotlinhax.shadowroutines.selects/SelectClause0 : kotlinhax.shadowroutines.selects/SelectClause // kotlinhax.shadowroutines.selects/SelectClause0|null[0]

abstract class <#A: in kotlin/Any?> kotlinhax.shadowroutines/AbstractCoroutine : kotlin.coroutines/Continuation<#A>, kotlinhax.shadowroutines/CoroutineScope, kotlinhax.shadowroutines/Job, kotlinhax.shadowroutines/JobSupport { // kotlinhax.shadowroutines/AbstractCoroutine|null[0]
    constructor <init>(kotlin.coroutines/CoroutineContext, kotlin/Boolean, kotlin/Boolean) // kotlinhax.shadowroutines/AbstractCoroutine.<init>|<init>(kotlin.coroutines.CoroutineContext;kotlin.Boolean;kotlin.Boolean){}[0]

    final val context // kotlinhax.shadowroutines/AbstractCoroutine.context|{}context[0]
        final fun <get-context>(): kotlin.coroutines/CoroutineContext // kotlinhax.shadowroutines/AbstractCoroutine.context.<get-context>|<get-context>(){}[0]
    open val coroutineContext // kotlinhax.shadowroutines/AbstractCoroutine.coroutineContext|{}coroutineContext[0]
        open fun <get-coroutineContext>(): kotlin.coroutines/CoroutineContext // kotlinhax.shadowroutines/AbstractCoroutine.coroutineContext.<get-coroutineContext>|<get-coroutineContext>(){}[0]
    open val isActive // kotlinhax.shadowroutines/AbstractCoroutine.isActive|{}isActive[0]
        open fun <get-isActive>(): kotlin/Boolean // kotlinhax.shadowroutines/AbstractCoroutine.isActive.<get-isActive>|<get-isActive>(){}[0]

    final fun <#A1: kotlin/Any?> start(kotlinhax.shadowroutines/CoroutineStart, #A1, kotlin.coroutines/SuspendFunction1<#A1, #A>) // kotlinhax.shadowroutines/AbstractCoroutine.start|start(kotlinhax.shadowroutines.CoroutineStart;0:0;kotlin.coroutines.SuspendFunction1<0:0,1:0>){0§<kotlin.Any?>}[0]
    final fun onCompletionInternal(kotlin/Any?) // kotlinhax.shadowroutines/AbstractCoroutine.onCompletionInternal|onCompletionInternal(kotlin.Any?){}[0]
    final fun resumeWith(kotlin/Result<#A>) // kotlinhax.shadowroutines/AbstractCoroutine.resumeWith|resumeWith(kotlin.Result<1:0>){}[0]
    open fun afterResume(kotlin/Any?) // kotlinhax.shadowroutines/AbstractCoroutine.afterResume|afterResume(kotlin.Any?){}[0]
    open fun cancellationExceptionMessage(): kotlin/String // kotlinhax.shadowroutines/AbstractCoroutine.cancellationExceptionMessage|cancellationExceptionMessage(){}[0]
    open fun onCancelled(kotlin/Throwable, kotlin/Boolean) // kotlinhax.shadowroutines/AbstractCoroutine.onCancelled|onCancelled(kotlin.Throwable;kotlin.Boolean){}[0]
    open fun onCompleted(#A) // kotlinhax.shadowroutines/AbstractCoroutine.onCompleted|onCompleted(1:0){}[0]
}

abstract class <#A: kotlin/Any?> kotlinhax.shadowroutines.flow.internal/ChannelFlow : kotlinhax.shadowroutines.flow.internal/FusibleFlow<#A> { // kotlinhax.shadowroutines.flow.internal/ChannelFlow|null[0]
    constructor <init>(kotlin.coroutines/CoroutineContext, kotlin/Int, kotlinhax.shadowroutines.channels/BufferOverflow) // kotlinhax.shadowroutines.flow.internal/ChannelFlow.<init>|<init>(kotlin.coroutines.CoroutineContext;kotlin.Int;kotlinhax.shadowroutines.channels.BufferOverflow){}[0]

    final val capacity // kotlinhax.shadowroutines.flow.internal/ChannelFlow.capacity|{}capacity[0]
        final fun <get-capacity>(): kotlin/Int // kotlinhax.shadowroutines.flow.internal/ChannelFlow.capacity.<get-capacity>|<get-capacity>(){}[0]
    final val context // kotlinhax.shadowroutines.flow.internal/ChannelFlow.context|{}context[0]
        final fun <get-context>(): kotlin.coroutines/CoroutineContext // kotlinhax.shadowroutines.flow.internal/ChannelFlow.context.<get-context>|<get-context>(){}[0]
    final val onBufferOverflow // kotlinhax.shadowroutines.flow.internal/ChannelFlow.onBufferOverflow|{}onBufferOverflow[0]
        final fun <get-onBufferOverflow>(): kotlinhax.shadowroutines.channels/BufferOverflow // kotlinhax.shadowroutines.flow.internal/ChannelFlow.onBufferOverflow.<get-onBufferOverflow>|<get-onBufferOverflow>(){}[0]

    abstract fun create(kotlin.coroutines/CoroutineContext, kotlin/Int, kotlinhax.shadowroutines.channels/BufferOverflow): kotlinhax.shadowroutines.flow.internal/ChannelFlow<#A> // kotlinhax.shadowroutines.flow.internal/ChannelFlow.create|create(kotlin.coroutines.CoroutineContext;kotlin.Int;kotlinhax.shadowroutines.channels.BufferOverflow){}[0]
    abstract suspend fun collectTo(kotlinhax.shadowroutines.channels/ProducerScope<#A>) // kotlinhax.shadowroutines.flow.internal/ChannelFlow.collectTo|collectTo(kotlinhax.shadowroutines.channels.ProducerScope<1:0>){}[0]
    open fun additionalToStringProps(): kotlin/String? // kotlinhax.shadowroutines.flow.internal/ChannelFlow.additionalToStringProps|additionalToStringProps(){}[0]
    open fun dropChannelOperators(): kotlinhax.shadowroutines.flow/Flow<#A>? // kotlinhax.shadowroutines.flow.internal/ChannelFlow.dropChannelOperators|dropChannelOperators(){}[0]
    open fun fuse(kotlin.coroutines/CoroutineContext, kotlin/Int, kotlinhax.shadowroutines.channels/BufferOverflow): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow.internal/ChannelFlow.fuse|fuse(kotlin.coroutines.CoroutineContext;kotlin.Int;kotlinhax.shadowroutines.channels.BufferOverflow){}[0]
    open fun produceImpl(kotlinhax.shadowroutines/CoroutineScope): kotlinhax.shadowroutines.channels/ReceiveChannel<#A> // kotlinhax.shadowroutines.flow.internal/ChannelFlow.produceImpl|produceImpl(kotlinhax.shadowroutines.CoroutineScope){}[0]
    open fun toString(): kotlin/String // kotlinhax.shadowroutines.flow.internal/ChannelFlow.toString|toString(){}[0]
    open suspend fun collect(kotlinhax.shadowroutines.flow/FlowCollector<#A>) // kotlinhax.shadowroutines.flow.internal/ChannelFlow.collect|collect(kotlinhax.shadowroutines.flow.FlowCollector<1:0>){}[0]
}

abstract class <#A: kotlin/Any?> kotlinhax.shadowroutines.flow/AbstractFlow : kotlinhax.shadowroutines.flow/CancellableFlow<#A>, kotlinhax.shadowroutines.flow/Flow<#A> { // kotlinhax.shadowroutines.flow/AbstractFlow|null[0]
    constructor <init>() // kotlinhax.shadowroutines.flow/AbstractFlow.<init>|<init>(){}[0]

    abstract suspend fun collectSafely(kotlinhax.shadowroutines.flow/FlowCollector<#A>) // kotlinhax.shadowroutines.flow/AbstractFlow.collectSafely|collectSafely(kotlinhax.shadowroutines.flow.FlowCollector<1:0>){}[0]
    final suspend fun collect(kotlinhax.shadowroutines.flow/FlowCollector<#A>) // kotlinhax.shadowroutines.flow/AbstractFlow.collect|collect(kotlinhax.shadowroutines.flow.FlowCollector<1:0>){}[0]
}

abstract class kotlinhax.shadowroutines/CloseableCoroutineDispatcher : kotlin/AutoCloseable, kotlinhax.shadowroutines/CoroutineDispatcher { // kotlinhax.shadowroutines/CloseableCoroutineDispatcher|null[0]
    constructor <init>() // kotlinhax.shadowroutines/CloseableCoroutineDispatcher.<init>|<init>(){}[0]

    abstract fun close() // kotlinhax.shadowroutines/CloseableCoroutineDispatcher.close|close(){}[0]
}

abstract class kotlinhax.shadowroutines/CoroutineDispatcher : kotlin.coroutines/AbstractCoroutineContextElement, kotlin.coroutines/ContinuationInterceptor { // kotlinhax.shadowroutines/CoroutineDispatcher|null[0]
    constructor <init>() // kotlinhax.shadowroutines/CoroutineDispatcher.<init>|<init>(){}[0]

    abstract fun dispatch(kotlin.coroutines/CoroutineContext, kotlinhax.shadowroutines/Runnable) // kotlinhax.shadowroutines/CoroutineDispatcher.dispatch|dispatch(kotlin.coroutines.CoroutineContext;kotlinhax.shadowroutines.Runnable){}[0]
    final fun <#A1: kotlin/Any?> interceptContinuation(kotlin.coroutines/Continuation<#A1>): kotlin.coroutines/Continuation<#A1> // kotlinhax.shadowroutines/CoroutineDispatcher.interceptContinuation|interceptContinuation(kotlin.coroutines.Continuation<0:0>){0§<kotlin.Any?>}[0]
    final fun plus(kotlinhax.shadowroutines/CoroutineDispatcher): kotlinhax.shadowroutines/CoroutineDispatcher // kotlinhax.shadowroutines/CoroutineDispatcher.plus|plus(kotlinhax.shadowroutines.CoroutineDispatcher){}[0]
    final fun releaseInterceptedContinuation(kotlin.coroutines/Continuation<*>) // kotlinhax.shadowroutines/CoroutineDispatcher.releaseInterceptedContinuation|releaseInterceptedContinuation(kotlin.coroutines.Continuation<*>){}[0]
    open fun dispatchYield(kotlin.coroutines/CoroutineContext, kotlinhax.shadowroutines/Runnable) // kotlinhax.shadowroutines/CoroutineDispatcher.dispatchYield|dispatchYield(kotlin.coroutines.CoroutineContext;kotlinhax.shadowroutines.Runnable){}[0]
    open fun isDispatchNeeded(kotlin.coroutines/CoroutineContext): kotlin/Boolean // kotlinhax.shadowroutines/CoroutineDispatcher.isDispatchNeeded|isDispatchNeeded(kotlin.coroutines.CoroutineContext){}[0]
    open fun limitedParallelism(kotlin/Int): kotlinhax.shadowroutines/CoroutineDispatcher // kotlinhax.shadowroutines/CoroutineDispatcher.limitedParallelism|limitedParallelism(kotlin.Int){}[0]
    open fun limitedParallelism(kotlin/Int, kotlin/String? = ...): kotlinhax.shadowroutines/CoroutineDispatcher // kotlinhax.shadowroutines/CoroutineDispatcher.limitedParallelism|limitedParallelism(kotlin.Int;kotlin.String?){}[0]
    open fun toString(): kotlin/String // kotlinhax.shadowroutines/CoroutineDispatcher.toString|toString(){}[0]

    final object Key : kotlin.coroutines/AbstractCoroutineContextKey<kotlin.coroutines/ContinuationInterceptor, kotlinhax.shadowroutines/CoroutineDispatcher> // kotlinhax.shadowroutines/CoroutineDispatcher.Key|null[0]
}

abstract class kotlinhax.shadowroutines/MainCoroutineDispatcher : kotlinhax.shadowroutines/CoroutineDispatcher { // kotlinhax.shadowroutines/MainCoroutineDispatcher|null[0]
    constructor <init>() // kotlinhax.shadowroutines/MainCoroutineDispatcher.<init>|<init>(){}[0]

    abstract val immediate // kotlinhax.shadowroutines/MainCoroutineDispatcher.immediate|{}immediate[0]
        abstract fun <get-immediate>(): kotlinhax.shadowroutines/MainCoroutineDispatcher // kotlinhax.shadowroutines/MainCoroutineDispatcher.immediate.<get-immediate>|<get-immediate>(){}[0]

    final fun toStringInternalImpl(): kotlin/String? // kotlinhax.shadowroutines/MainCoroutineDispatcher.toStringInternalImpl|toStringInternalImpl(){}[0]
    open fun limitedParallelism(kotlin/Int, kotlin/String?): kotlinhax.shadowroutines/CoroutineDispatcher // kotlinhax.shadowroutines/MainCoroutineDispatcher.limitedParallelism|limitedParallelism(kotlin.Int;kotlin.String?){}[0]
    open fun toString(): kotlin/String // kotlinhax.shadowroutines/MainCoroutineDispatcher.toString|toString(){}[0]
}

final class <#A: kotlin/Any?> kotlinhax.shadowroutines.channels/ConflatedBroadcastChannel : kotlinhax.shadowroutines.channels/BroadcastChannel<#A> { // kotlinhax.shadowroutines.channels/ConflatedBroadcastChannel|null[0]
    constructor <init>(#A) // kotlinhax.shadowroutines.channels/ConflatedBroadcastChannel.<init>|<init>(1:0){}[0]
    constructor <init>() // kotlinhax.shadowroutines.channels/ConflatedBroadcastChannel.<init>|<init>(){}[0]

    final val isClosedForSend // kotlinhax.shadowroutines.channels/ConflatedBroadcastChannel.isClosedForSend|{}isClosedForSend[0]
        final fun <get-isClosedForSend>(): kotlin/Boolean // kotlinhax.shadowroutines.channels/ConflatedBroadcastChannel.isClosedForSend.<get-isClosedForSend>|<get-isClosedForSend>(){}[0]
    final val onSend // kotlinhax.shadowroutines.channels/ConflatedBroadcastChannel.onSend|{}onSend[0]
        final fun <get-onSend>(): kotlinhax.shadowroutines.selects/SelectClause2<#A, kotlinhax.shadowroutines.channels/SendChannel<#A>> // kotlinhax.shadowroutines.channels/ConflatedBroadcastChannel.onSend.<get-onSend>|<get-onSend>(){}[0]
    final val value // kotlinhax.shadowroutines.channels/ConflatedBroadcastChannel.value|{}value[0]
        final fun <get-value>(): #A // kotlinhax.shadowroutines.channels/ConflatedBroadcastChannel.value.<get-value>|<get-value>(){}[0]
    final val valueOrNull // kotlinhax.shadowroutines.channels/ConflatedBroadcastChannel.valueOrNull|{}valueOrNull[0]
        final fun <get-valueOrNull>(): #A? // kotlinhax.shadowroutines.channels/ConflatedBroadcastChannel.valueOrNull.<get-valueOrNull>|<get-valueOrNull>(){}[0]

    final fun cancel(kotlin.coroutines.cancellation/CancellationException?) // kotlinhax.shadowroutines.channels/ConflatedBroadcastChannel.cancel|cancel(kotlin.coroutines.cancellation.CancellationException?){}[0]
    final fun cancel(kotlin/Throwable?): kotlin/Boolean // kotlinhax.shadowroutines.channels/ConflatedBroadcastChannel.cancel|cancel(kotlin.Throwable?){}[0]
    final fun close(kotlin/Throwable?): kotlin/Boolean // kotlinhax.shadowroutines.channels/ConflatedBroadcastChannel.close|close(kotlin.Throwable?){}[0]
    final fun invokeOnClose(kotlin/Function1<kotlin/Throwable?, kotlin/Unit>) // kotlinhax.shadowroutines.channels/ConflatedBroadcastChannel.invokeOnClose|invokeOnClose(kotlin.Function1<kotlin.Throwable?,kotlin.Unit>){}[0]
    final fun offer(#A): kotlin/Boolean // kotlinhax.shadowroutines.channels/ConflatedBroadcastChannel.offer|offer(1:0){}[0]
    final fun openSubscription(): kotlinhax.shadowroutines.channels/ReceiveChannel<#A> // kotlinhax.shadowroutines.channels/ConflatedBroadcastChannel.openSubscription|openSubscription(){}[0]
    final fun trySend(#A): kotlinhax.shadowroutines.channels/ChannelResult<kotlin/Unit> // kotlinhax.shadowroutines.channels/ConflatedBroadcastChannel.trySend|trySend(1:0){}[0]
    final suspend fun send(#A) // kotlinhax.shadowroutines.channels/ConflatedBroadcastChannel.send|send(1:0){}[0]
}

final class <#A: kotlin/Any?> kotlinhax.shadowroutines.flow.internal/SendingCollector : kotlinhax.shadowroutines.flow/FlowCollector<#A> { // kotlinhax.shadowroutines.flow.internal/SendingCollector|null[0]
    constructor <init>(kotlinhax.shadowroutines.channels/SendChannel<#A>) // kotlinhax.shadowroutines.flow.internal/SendingCollector.<init>|<init>(kotlinhax.shadowroutines.channels.SendChannel<1:0>){}[0]

    final suspend fun emit(#A) // kotlinhax.shadowroutines.flow.internal/SendingCollector.emit|emit(1:0){}[0]
}

final class <#A: kotlin/Any?> kotlinhax.shadowroutines.selects/SelectBuilderImpl : kotlinhax.shadowroutines.selects/SelectImplementation<#A> { // kotlinhax.shadowroutines.selects/SelectBuilderImpl|null[0]
    constructor <init>(kotlin.coroutines/Continuation<#A>) // kotlinhax.shadowroutines.selects/SelectBuilderImpl.<init>|<init>(kotlin.coroutines.Continuation<1:0>){}[0]

    final fun getResult(): kotlin/Any? // kotlinhax.shadowroutines.selects/SelectBuilderImpl.getResult|getResult(){}[0]
    final fun handleBuilderException(kotlin/Throwable) // kotlinhax.shadowroutines.selects/SelectBuilderImpl.handleBuilderException|handleBuilderException(kotlin.Throwable){}[0]
}

final class <#A: kotlin/Any?> kotlinhax.shadowroutines.selects/UnbiasedSelectBuilderImpl : kotlinhax.shadowroutines.selects/UnbiasedSelectImplementation<#A> { // kotlinhax.shadowroutines.selects/UnbiasedSelectBuilderImpl|null[0]
    constructor <init>(kotlin.coroutines/Continuation<#A>) // kotlinhax.shadowroutines.selects/UnbiasedSelectBuilderImpl.<init>|<init>(kotlin.coroutines.Continuation<1:0>){}[0]

    final fun handleBuilderException(kotlin/Throwable) // kotlinhax.shadowroutines.selects/UnbiasedSelectBuilderImpl.handleBuilderException|handleBuilderException(kotlin.Throwable){}[0]
    final fun initSelectResult(): kotlin/Any? // kotlinhax.shadowroutines.selects/UnbiasedSelectBuilderImpl.initSelectResult|initSelectResult(){}[0]
}

final class kotlinhax.shadowroutines.channels/ClosedReceiveChannelException : kotlin/NoSuchElementException { // kotlinhax.shadowroutines.channels/ClosedReceiveChannelException|null[0]
    constructor <init>(kotlin/String?) // kotlinhax.shadowroutines.channels/ClosedReceiveChannelException.<init>|<init>(kotlin.String?){}[0]
}

final class kotlinhax.shadowroutines.channels/ClosedSendChannelException : kotlin/IllegalStateException { // kotlinhax.shadowroutines.channels/ClosedSendChannelException|null[0]
    constructor <init>(kotlin/String?) // kotlinhax.shadowroutines.channels/ClosedSendChannelException.<init>|<init>(kotlin.String?){}[0]
}

final class kotlinhax.shadowroutines/CompletionHandlerException : kotlin/RuntimeException { // kotlinhax.shadowroutines/CompletionHandlerException|null[0]
    constructor <init>(kotlin/String, kotlin/Throwable) // kotlinhax.shadowroutines/CompletionHandlerException.<init>|<init>(kotlin.String;kotlin.Throwable){}[0]
}

final class kotlinhax.shadowroutines/CoroutineName : kotlin.coroutines/AbstractCoroutineContextElement { // kotlinhax.shadowroutines/CoroutineName|null[0]
    constructor <init>(kotlin/String) // kotlinhax.shadowroutines/CoroutineName.<init>|<init>(kotlin.String){}[0]

    final val name // kotlinhax.shadowroutines/CoroutineName.name|{}name[0]
        final fun <get-name>(): kotlin/String // kotlinhax.shadowroutines/CoroutineName.name.<get-name>|<get-name>(){}[0]

    final fun component1(): kotlin/String // kotlinhax.shadowroutines/CoroutineName.component1|component1(){}[0]
    final fun copy(kotlin/String = ...): kotlinhax.shadowroutines/CoroutineName // kotlinhax.shadowroutines/CoroutineName.copy|copy(kotlin.String){}[0]
    final fun equals(kotlin/Any?): kotlin/Boolean // kotlinhax.shadowroutines/CoroutineName.equals|equals(kotlin.Any?){}[0]
    final fun hashCode(): kotlin/Int // kotlinhax.shadowroutines/CoroutineName.hashCode|hashCode(){}[0]
    final fun toString(): kotlin/String // kotlinhax.shadowroutines/CoroutineName.toString|toString(){}[0]

    final object Key : kotlin.coroutines/CoroutineContext.Key<kotlinhax.shadowroutines/CoroutineName> // kotlinhax.shadowroutines/CoroutineName.Key|null[0]
}

final class kotlinhax.shadowroutines/TimeoutCancellationException : kotlin.coroutines.cancellation/CancellationException, kotlinhax.shadowroutines/CopyableThrowable<kotlinhax.shadowroutines/TimeoutCancellationException> { // kotlinhax.shadowroutines/TimeoutCancellationException|null[0]
    final fun createCopy(): kotlinhax.shadowroutines/TimeoutCancellationException // kotlinhax.shadowroutines/TimeoutCancellationException.createCopy|createCopy(){}[0]
}

final class kotlinhax.shadowroutines/YieldContext : kotlin.coroutines/AbstractCoroutineContextElement { // kotlinhax.shadowroutines/YieldContext|null[0]
    constructor <init>() // kotlinhax.shadowroutines/YieldContext.<init>|<init>(){}[0]

    final var dispatcherWasUnconfined // kotlinhax.shadowroutines/YieldContext.dispatcherWasUnconfined|{}dispatcherWasUnconfined[0]
        final fun <get-dispatcherWasUnconfined>(): kotlin/Boolean // kotlinhax.shadowroutines/YieldContext.dispatcherWasUnconfined.<get-dispatcherWasUnconfined>|<get-dispatcherWasUnconfined>(){}[0]
        final fun <set-dispatcherWasUnconfined>(kotlin/Boolean) // kotlinhax.shadowroutines/YieldContext.dispatcherWasUnconfined.<set-dispatcherWasUnconfined>|<set-dispatcherWasUnconfined>(kotlin.Boolean){}[0]

    final object Key : kotlin.coroutines/CoroutineContext.Key<kotlinhax.shadowroutines/YieldContext> // kotlinhax.shadowroutines/YieldContext.Key|null[0]
}

final value class <#A: out kotlin/Any?> kotlinhax.shadowroutines.channels/ChannelResult { // kotlinhax.shadowroutines.channels/ChannelResult|null[0]
    constructor <init>(kotlin/Any?) // kotlinhax.shadowroutines.channels/ChannelResult.<init>|<init>(kotlin.Any?){}[0]

    final val holder // kotlinhax.shadowroutines.channels/ChannelResult.holder|{}holder[0]
        final fun <get-holder>(): kotlin/Any? // kotlinhax.shadowroutines.channels/ChannelResult.holder.<get-holder>|<get-holder>(){}[0]
    final val isClosed // kotlinhax.shadowroutines.channels/ChannelResult.isClosed|{}isClosed[0]
        final fun <get-isClosed>(): kotlin/Boolean // kotlinhax.shadowroutines.channels/ChannelResult.isClosed.<get-isClosed>|<get-isClosed>(){}[0]
    final val isFailure // kotlinhax.shadowroutines.channels/ChannelResult.isFailure|{}isFailure[0]
        final fun <get-isFailure>(): kotlin/Boolean // kotlinhax.shadowroutines.channels/ChannelResult.isFailure.<get-isFailure>|<get-isFailure>(){}[0]
    final val isSuccess // kotlinhax.shadowroutines.channels/ChannelResult.isSuccess|{}isSuccess[0]
        final fun <get-isSuccess>(): kotlin/Boolean // kotlinhax.shadowroutines.channels/ChannelResult.isSuccess.<get-isSuccess>|<get-isSuccess>(){}[0]

    final fun equals(kotlin/Any?): kotlin/Boolean // kotlinhax.shadowroutines.channels/ChannelResult.equals|equals(kotlin.Any?){}[0]
    final fun exceptionOrNull(): kotlin/Throwable? // kotlinhax.shadowroutines.channels/ChannelResult.exceptionOrNull|exceptionOrNull(){}[0]
    final fun getOrNull(): #A? // kotlinhax.shadowroutines.channels/ChannelResult.getOrNull|getOrNull(){}[0]
    final fun getOrThrow(): #A // kotlinhax.shadowroutines.channels/ChannelResult.getOrThrow|getOrThrow(){}[0]
    final fun hashCode(): kotlin/Int // kotlinhax.shadowroutines.channels/ChannelResult.hashCode|hashCode(){}[0]
    final fun toString(): kotlin/String // kotlinhax.shadowroutines.channels/ChannelResult.toString|toString(){}[0]

    final object Companion { // kotlinhax.shadowroutines.channels/ChannelResult.Companion|null[0]
        final fun <#A2: kotlin/Any?> closed(kotlin/Throwable?): kotlinhax.shadowroutines.channels/ChannelResult<#A2> // kotlinhax.shadowroutines.channels/ChannelResult.Companion.closed|closed(kotlin.Throwable?){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> failure(): kotlinhax.shadowroutines.channels/ChannelResult<#A2> // kotlinhax.shadowroutines.channels/ChannelResult.Companion.failure|failure(){0§<kotlin.Any?>}[0]
        final fun <#A2: kotlin/Any?> success(#A2): kotlinhax.shadowroutines.channels/ChannelResult<#A2> // kotlinhax.shadowroutines.channels/ChannelResult.Companion.success|success(0:0){0§<kotlin.Any?>}[0]
    }
}

open class <#A: in kotlin/Any?> kotlinhax.shadowroutines/CancellableContinuationImpl : kotlinhax.shadowroutines.internal/CoroutineStackFrame, kotlinhax.shadowroutines/CancellableContinuation<#A>, kotlinhax.shadowroutines/DispatchedTask<#A>, kotlinhax.shadowroutines/Waiter { // kotlinhax.shadowroutines/CancellableContinuationImpl|null[0]
    constructor <init>(kotlin.coroutines/Continuation<#A>, kotlin/Int) // kotlinhax.shadowroutines/CancellableContinuationImpl.<init>|<init>(kotlin.coroutines.Continuation<1:0>;kotlin.Int){}[0]

    open val callerFrame // kotlinhax.shadowroutines/CancellableContinuationImpl.callerFrame|{}callerFrame[0]
        open fun <get-callerFrame>(): kotlinhax.shadowroutines.internal/CoroutineStackFrame? // kotlinhax.shadowroutines/CancellableContinuationImpl.callerFrame.<get-callerFrame>|<get-callerFrame>(){}[0]
    open val context // kotlinhax.shadowroutines/CancellableContinuationImpl.context|{}context[0]
        open fun <get-context>(): kotlin.coroutines/CoroutineContext // kotlinhax.shadowroutines/CancellableContinuationImpl.context.<get-context>|<get-context>(){}[0]
    open val isActive // kotlinhax.shadowroutines/CancellableContinuationImpl.isActive|{}isActive[0]
        open fun <get-isActive>(): kotlin/Boolean // kotlinhax.shadowroutines/CancellableContinuationImpl.isActive.<get-isActive>|<get-isActive>(){}[0]
    open val isCancelled // kotlinhax.shadowroutines/CancellableContinuationImpl.isCancelled|{}isCancelled[0]
        open fun <get-isCancelled>(): kotlin/Boolean // kotlinhax.shadowroutines/CancellableContinuationImpl.isCancelled.<get-isCancelled>|<get-isCancelled>(){}[0]
    open val isCompleted // kotlinhax.shadowroutines/CancellableContinuationImpl.isCompleted|{}isCompleted[0]
        open fun <get-isCompleted>(): kotlin/Boolean // kotlinhax.shadowroutines/CancellableContinuationImpl.isCompleted.<get-isCompleted>|<get-isCompleted>(){}[0]

    final fun <#A1: kotlin/Any?> callOnCancellation(kotlin/Function3<kotlin/Throwable, #A1, kotlin.coroutines/CoroutineContext, kotlin/Unit>, kotlin/Throwable, #A1) // kotlinhax.shadowroutines/CancellableContinuationImpl.callOnCancellation|callOnCancellation(kotlin.Function3<kotlin.Throwable,0:0,kotlin.coroutines.CoroutineContext,kotlin.Unit>;kotlin.Throwable;0:0){0§<kotlin.Any?>}[0]
    final fun callCancelHandler(kotlinhax.shadowroutines/CancelHandler, kotlin/Throwable?) // kotlinhax.shadowroutines/CancellableContinuationImpl.callCancelHandler|callCancelHandler(kotlinhax.shadowroutines.CancelHandler;kotlin.Throwable?){}[0]
    final fun getResult(): kotlin/Any? // kotlinhax.shadowroutines/CancellableContinuationImpl.getResult|getResult(){}[0]
    open fun (kotlinhax.shadowroutines/CoroutineDispatcher).resumeUndispatched(#A) // kotlinhax.shadowroutines/CancellableContinuationImpl.resumeUndispatched|resumeUndispatched@kotlinhax.shadowroutines.CoroutineDispatcher(1:0){}[0]
    open fun (kotlinhax.shadowroutines/CoroutineDispatcher).resumeUndispatchedWithException(kotlin/Throwable) // kotlinhax.shadowroutines/CancellableContinuationImpl.resumeUndispatchedWithException|resumeUndispatchedWithException@kotlinhax.shadowroutines.CoroutineDispatcher(kotlin.Throwable){}[0]
    open fun <#A1: #A> resume(#A1, kotlin/Function3<kotlin/Throwable, #A1, kotlin.coroutines/CoroutineContext, kotlin/Unit>?) // kotlinhax.shadowroutines/CancellableContinuationImpl.resume|resume(0:0;kotlin.Function3<kotlin.Throwable,0:0,kotlin.coroutines.CoroutineContext,kotlin.Unit>?){0§<1:0>}[0]
    open fun <#A1: #A> tryResume(#A1, kotlin/Any?, kotlin/Function3<kotlin/Throwable, #A1, kotlin.coroutines/CoroutineContext, kotlin/Unit>?): kotlin/Any? // kotlinhax.shadowroutines/CancellableContinuationImpl.tryResume|tryResume(0:0;kotlin.Any?;kotlin.Function3<kotlin.Throwable,0:0,kotlin.coroutines.CoroutineContext,kotlin.Unit>?){0§<1:0>}[0]
    open fun cancel(kotlin/Throwable?): kotlin/Boolean // kotlinhax.shadowroutines/CancellableContinuationImpl.cancel|cancel(kotlin.Throwable?){}[0]
    open fun completeResume(kotlin/Any) // kotlinhax.shadowroutines/CancellableContinuationImpl.completeResume|completeResume(kotlin.Any){}[0]
    open fun getContinuationCancellationCause(kotlinhax.shadowroutines/Job): kotlin/Throwable // kotlinhax.shadowroutines/CancellableContinuationImpl.getContinuationCancellationCause|getContinuationCancellationCause(kotlinhax.shadowroutines.Job){}[0]
    open fun getStackTraceElement(): kotlin/Any? // kotlinhax.shadowroutines/CancellableContinuationImpl.getStackTraceElement|getStackTraceElement(){}[0]
    open fun initCancellability() // kotlinhax.shadowroutines/CancellableContinuationImpl.initCancellability|initCancellability(){}[0]
    open fun invokeOnCancellation(kotlin/Function1<kotlin/Throwable?, kotlin/Unit>) // kotlinhax.shadowroutines/CancellableContinuationImpl.invokeOnCancellation|invokeOnCancellation(kotlin.Function1<kotlin.Throwable?,kotlin.Unit>){}[0]
    open fun invokeOnCancellation(kotlinhax.shadowroutines.internal/Segment<*>, kotlin/Int) // kotlinhax.shadowroutines/CancellableContinuationImpl.invokeOnCancellation|invokeOnCancellation(kotlinhax.shadowroutines.internal.Segment<*>;kotlin.Int){}[0]
    open fun nameString(): kotlin/String // kotlinhax.shadowroutines/CancellableContinuationImpl.nameString|nameString(){}[0]
    open fun resume(#A, kotlin/Function1<kotlin/Throwable, kotlin/Unit>?) // kotlinhax.shadowroutines/CancellableContinuationImpl.resume|resume(1:0;kotlin.Function1<kotlin.Throwable,kotlin.Unit>?){}[0]
    open fun resumeWith(kotlin/Result<#A>) // kotlinhax.shadowroutines/CancellableContinuationImpl.resumeWith|resumeWith(kotlin.Result<1:0>){}[0]
    open fun toString(): kotlin/String // kotlinhax.shadowroutines/CancellableContinuationImpl.toString|toString(){}[0]
    open fun tryResume(#A, kotlin/Any?): kotlin/Any? // kotlinhax.shadowroutines/CancellableContinuationImpl.tryResume|tryResume(1:0;kotlin.Any?){}[0]
    open fun tryResumeWithException(kotlin/Throwable): kotlin/Any? // kotlinhax.shadowroutines/CancellableContinuationImpl.tryResumeWithException|tryResumeWithException(kotlin.Throwable){}[0]
}

open class <#A: kotlin/Any?> kotlinhax.shadowroutines.selects/SelectImplementation : kotlinhax.shadowroutines.selects/SelectBuilder<#A>, kotlinhax.shadowroutines.selects/SelectInstanceInternal<#A>, kotlinhax.shadowroutines/CancelHandler { // kotlinhax.shadowroutines.selects/SelectImplementation|null[0]
    constructor <init>(kotlin.coroutines/CoroutineContext) // kotlinhax.shadowroutines.selects/SelectImplementation.<init>|<init>(kotlin.coroutines.CoroutineContext){}[0]

    open val context // kotlinhax.shadowroutines.selects/SelectImplementation.context|{}context[0]
        open fun <get-context>(): kotlin.coroutines/CoroutineContext // kotlinhax.shadowroutines.selects/SelectImplementation.context.<get-context>|<get-context>(){}[0]

    final fun trySelectDetailed(kotlin/Any, kotlin/Any?): kotlinhax.shadowroutines.selects/TrySelectDetailedResult // kotlinhax.shadowroutines.selects/SelectImplementation.trySelectDetailed|trySelectDetailed(kotlin.Any;kotlin.Any?){}[0]
    open fun (kotlinhax.shadowroutines.selects/SelectClause0).invoke(kotlin.coroutines/SuspendFunction0<#A>) // kotlinhax.shadowroutines.selects/SelectImplementation.invoke|invoke@kotlinhax.shadowroutines.selects.SelectClause0(kotlin.coroutines.SuspendFunction0<1:0>){}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> (kotlinhax.shadowroutines.selects/SelectClause2<#A1, #B1>).invoke(#A1, kotlin.coroutines/SuspendFunction1<#B1, #A>) // kotlinhax.shadowroutines.selects/SelectImplementation.invoke|invoke@kotlinhax.shadowroutines.selects.SelectClause2<0:0,0:1>(0:0;kotlin.coroutines.SuspendFunction1<0:1,1:0>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> (kotlinhax.shadowroutines.selects/SelectClause1<#A1>).invoke(kotlin.coroutines/SuspendFunction1<#A1, #A>) // kotlinhax.shadowroutines.selects/SelectImplementation.invoke|invoke@kotlinhax.shadowroutines.selects.SelectClause1<0:0>(kotlin.coroutines.SuspendFunction1<0:0,1:0>){0§<kotlin.Any?>}[0]
    open fun disposeOnCompletion(kotlinhax.shadowroutines/DisposableHandle) // kotlinhax.shadowroutines.selects/SelectImplementation.disposeOnCompletion|disposeOnCompletion(kotlinhax.shadowroutines.DisposableHandle){}[0]
    open fun invoke(kotlin/Throwable?) // kotlinhax.shadowroutines.selects/SelectImplementation.invoke|invoke(kotlin.Throwable?){}[0]
    open fun invokeOnCancellation(kotlinhax.shadowroutines.internal/Segment<*>, kotlin/Int) // kotlinhax.shadowroutines.selects/SelectImplementation.invokeOnCancellation|invokeOnCancellation(kotlinhax.shadowroutines.internal.Segment<*>;kotlin.Int){}[0]
    open fun selectInRegistrationPhase(kotlin/Any?) // kotlinhax.shadowroutines.selects/SelectImplementation.selectInRegistrationPhase|selectInRegistrationPhase(kotlin.Any?){}[0]
    open fun trySelect(kotlin/Any, kotlin/Any?): kotlin/Boolean // kotlinhax.shadowroutines.selects/SelectImplementation.trySelect|trySelect(kotlin.Any;kotlin.Any?){}[0]
    open suspend fun doSelect(): #A // kotlinhax.shadowroutines.selects/SelectImplementation.doSelect|doSelect(){}[0]
}

open class <#A: kotlin/Any?> kotlinhax.shadowroutines.selects/UnbiasedSelectImplementation : kotlinhax.shadowroutines.selects/SelectImplementation<#A> { // kotlinhax.shadowroutines.selects/UnbiasedSelectImplementation|null[0]
    constructor <init>(kotlin.coroutines/CoroutineContext) // kotlinhax.shadowroutines.selects/UnbiasedSelectImplementation.<init>|<init>(kotlin.coroutines.CoroutineContext){}[0]

    open fun (kotlinhax.shadowroutines.selects/SelectClause0).invoke(kotlin.coroutines/SuspendFunction0<#A>) // kotlinhax.shadowroutines.selects/UnbiasedSelectImplementation.invoke|invoke@kotlinhax.shadowroutines.selects.SelectClause0(kotlin.coroutines.SuspendFunction0<1:0>){}[0]
    open fun <#A1: kotlin/Any?, #B1: kotlin/Any?> (kotlinhax.shadowroutines.selects/SelectClause2<#A1, #B1>).invoke(#A1, kotlin.coroutines/SuspendFunction1<#B1, #A>) // kotlinhax.shadowroutines.selects/UnbiasedSelectImplementation.invoke|invoke@kotlinhax.shadowroutines.selects.SelectClause2<0:0,0:1>(0:0;kotlin.coroutines.SuspendFunction1<0:1,1:0>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
    open fun <#A1: kotlin/Any?> (kotlinhax.shadowroutines.selects/SelectClause1<#A1>).invoke(kotlin.coroutines/SuspendFunction1<#A1, #A>) // kotlinhax.shadowroutines.selects/UnbiasedSelectImplementation.invoke|invoke@kotlinhax.shadowroutines.selects.SelectClause1<0:0>(kotlin.coroutines.SuspendFunction1<0:0,1:0>){0§<kotlin.Any?>}[0]
    open suspend fun doSelect(): #A // kotlinhax.shadowroutines.selects/UnbiasedSelectImplementation.doSelect|doSelect(){}[0]
}

open class kotlinhax.shadowroutines/JobImpl : kotlinhax.shadowroutines/CompletableJob, kotlinhax.shadowroutines/JobSupport { // kotlinhax.shadowroutines/JobImpl|null[0]
    constructor <init>(kotlinhax.shadowroutines/Job?) // kotlinhax.shadowroutines/JobImpl.<init>|<init>(kotlinhax.shadowroutines.Job?){}[0]

    open fun complete(): kotlin/Boolean // kotlinhax.shadowroutines/JobImpl.complete|complete(){}[0]
    open fun completeExceptionally(kotlin/Throwable): kotlin/Boolean // kotlinhax.shadowroutines/JobImpl.completeExceptionally|completeExceptionally(kotlin.Throwable){}[0]
}

open class kotlinhax.shadowroutines/JobSupport : kotlinhax.shadowroutines/ChildJob, kotlinhax.shadowroutines/Job, kotlinhax.shadowroutines/ParentJob { // kotlinhax.shadowroutines/JobSupport|null[0]
    constructor <init>(kotlin/Boolean) // kotlinhax.shadowroutines/JobSupport.<init>|<init>(kotlin.Boolean){}[0]

    final val children // kotlinhax.shadowroutines/JobSupport.children|{}children[0]
        final fun <get-children>(): kotlin.sequences/Sequence<kotlinhax.shadowroutines/Job> // kotlinhax.shadowroutines/JobSupport.children.<get-children>|<get-children>(){}[0]
    final val completionCause // kotlinhax.shadowroutines/JobSupport.completionCause|{}completionCause[0]
        final fun <get-completionCause>(): kotlin/Throwable? // kotlinhax.shadowroutines/JobSupport.completionCause.<get-completionCause>|<get-completionCause>(){}[0]
    final val completionCauseHandled // kotlinhax.shadowroutines/JobSupport.completionCauseHandled|{}completionCauseHandled[0]
        final fun <get-completionCauseHandled>(): kotlin/Boolean // kotlinhax.shadowroutines/JobSupport.completionCauseHandled.<get-completionCauseHandled>|<get-completionCauseHandled>(){}[0]
    final val isCancelled // kotlinhax.shadowroutines/JobSupport.isCancelled|{}isCancelled[0]
        final fun <get-isCancelled>(): kotlin/Boolean // kotlinhax.shadowroutines/JobSupport.isCancelled.<get-isCancelled>|<get-isCancelled>(){}[0]
    final val isCompleted // kotlinhax.shadowroutines/JobSupport.isCompleted|{}isCompleted[0]
        final fun <get-isCompleted>(): kotlin/Boolean // kotlinhax.shadowroutines/JobSupport.isCompleted.<get-isCompleted>|<get-isCompleted>(){}[0]
    final val isCompletedExceptionally // kotlinhax.shadowroutines/JobSupport.isCompletedExceptionally|{}isCompletedExceptionally[0]
        final fun <get-isCompletedExceptionally>(): kotlin/Boolean // kotlinhax.shadowroutines/JobSupport.isCompletedExceptionally.<get-isCompletedExceptionally>|<get-isCompletedExceptionally>(){}[0]
    final val key // kotlinhax.shadowroutines/JobSupport.key|{}key[0]
        final fun <get-key>(): kotlin.coroutines/CoroutineContext.Key<*> // kotlinhax.shadowroutines/JobSupport.key.<get-key>|<get-key>(){}[0]
    final val onAwaitInternal // kotlinhax.shadowroutines/JobSupport.onAwaitInternal|{}onAwaitInternal[0]
        final fun <get-onAwaitInternal>(): kotlinhax.shadowroutines.selects/SelectClause1<*> // kotlinhax.shadowroutines/JobSupport.onAwaitInternal.<get-onAwaitInternal>|<get-onAwaitInternal>(){}[0]
    final val onJoin // kotlinhax.shadowroutines/JobSupport.onJoin|{}onJoin[0]
        final fun <get-onJoin>(): kotlinhax.shadowroutines.selects/SelectClause0 // kotlinhax.shadowroutines/JobSupport.onJoin.<get-onJoin>|<get-onJoin>(){}[0]
    open val isActive // kotlinhax.shadowroutines/JobSupport.isActive|{}isActive[0]
        open fun <get-isActive>(): kotlin/Boolean // kotlinhax.shadowroutines/JobSupport.isActive.<get-isActive>|<get-isActive>(){}[0]
    open val isScopedCoroutine // kotlinhax.shadowroutines/JobSupport.isScopedCoroutine|{}isScopedCoroutine[0]
        open fun <get-isScopedCoroutine>(): kotlin/Boolean // kotlinhax.shadowroutines/JobSupport.isScopedCoroutine.<get-isScopedCoroutine>|<get-isScopedCoroutine>(){}[0]
    open val parent // kotlinhax.shadowroutines/JobSupport.parent|{}parent[0]
        open fun <get-parent>(): kotlinhax.shadowroutines/Job? // kotlinhax.shadowroutines/JobSupport.parent.<get-parent>|<get-parent>(){}[0]

    final fun (kotlin/Throwable).toCancellationException(kotlin/String? = ...): kotlin.coroutines.cancellation/CancellationException // kotlinhax.shadowroutines/JobSupport.toCancellationException|toCancellationException@kotlin.Throwable(kotlin.String?){}[0]
    final fun attachChild(kotlinhax.shadowroutines/ChildJob): kotlinhax.shadowroutines/ChildHandle // kotlinhax.shadowroutines/JobSupport.attachChild|attachChild(kotlinhax.shadowroutines.ChildJob){}[0]
    final fun cancelCoroutine(kotlin/Throwable?): kotlin/Boolean // kotlinhax.shadowroutines/JobSupport.cancelCoroutine|cancelCoroutine(kotlin.Throwable?){}[0]
    final fun getCancellationException(): kotlin.coroutines.cancellation/CancellationException // kotlinhax.shadowroutines/JobSupport.getCancellationException|getCancellationException(){}[0]
    final fun getCompletionExceptionOrNull(): kotlin/Throwable? // kotlinhax.shadowroutines/JobSupport.getCompletionExceptionOrNull|getCompletionExceptionOrNull(){}[0]
    final fun initParentJob(kotlinhax.shadowroutines/Job?) // kotlinhax.shadowroutines/JobSupport.initParentJob|initParentJob(kotlinhax.shadowroutines.Job?){}[0]
    final fun invokeOnCompletion(kotlin/Boolean, kotlin/Boolean, kotlin/Function1<kotlin/Throwable?, kotlin/Unit>): kotlinhax.shadowroutines/DisposableHandle // kotlinhax.shadowroutines/JobSupport.invokeOnCompletion|invokeOnCompletion(kotlin.Boolean;kotlin.Boolean;kotlin.Function1<kotlin.Throwable?,kotlin.Unit>){}[0]
    final fun invokeOnCompletion(kotlin/Function1<kotlin/Throwable?, kotlin/Unit>): kotlinhax.shadowroutines/DisposableHandle // kotlinhax.shadowroutines/JobSupport.invokeOnCompletion|invokeOnCompletion(kotlin.Function1<kotlin.Throwable?,kotlin.Unit>){}[0]
    final fun parentCancelled(kotlinhax.shadowroutines/ParentJob) // kotlinhax.shadowroutines/JobSupport.parentCancelled|parentCancelled(kotlinhax.shadowroutines.ParentJob){}[0]
    final fun start(): kotlin/Boolean // kotlinhax.shadowroutines/JobSupport.start|start(){}[0]
    final fun toDebugString(): kotlin/String // kotlinhax.shadowroutines/JobSupport.toDebugString|toDebugString(){}[0]
    final suspend fun awaitInternal(): kotlin/Any? // kotlinhax.shadowroutines/JobSupport.awaitInternal|awaitInternal(){}[0]
    final suspend fun join() // kotlinhax.shadowroutines/JobSupport.join|join(){}[0]
    open fun afterCompletion(kotlin/Any?) // kotlinhax.shadowroutines/JobSupport.afterCompletion|afterCompletion(kotlin.Any?){}[0]
    open fun cancel(kotlin.coroutines.cancellation/CancellationException?) // kotlinhax.shadowroutines/JobSupport.cancel|cancel(kotlin.coroutines.cancellation.CancellationException?){}[0]
    open fun cancel(kotlin/Throwable?): kotlin/Boolean // kotlinhax.shadowroutines/JobSupport.cancel|cancel(kotlin.Throwable?){}[0]
    open fun cancelInternal(kotlin/Throwable) // kotlinhax.shadowroutines/JobSupport.cancelInternal|cancelInternal(kotlin.Throwable){}[0]
    open fun cancellationExceptionMessage(): kotlin/String // kotlinhax.shadowroutines/JobSupport.cancellationExceptionMessage|cancellationExceptionMessage(){}[0]
    open fun childCancelled(kotlin/Throwable): kotlin/Boolean // kotlinhax.shadowroutines/JobSupport.childCancelled|childCancelled(kotlin.Throwable){}[0]
    open fun getChildJobCancellationCause(): kotlin.coroutines.cancellation/CancellationException // kotlinhax.shadowroutines/JobSupport.getChildJobCancellationCause|getChildJobCancellationCause(){}[0]
    open fun handleJobException(kotlin/Throwable): kotlin/Boolean // kotlinhax.shadowroutines/JobSupport.handleJobException|handleJobException(kotlin.Throwable){}[0]
    open fun onCancelling(kotlin/Throwable?) // kotlinhax.shadowroutines/JobSupport.onCancelling|onCancelling(kotlin.Throwable?){}[0]
    open fun onCompletionInternal(kotlin/Any?) // kotlinhax.shadowroutines/JobSupport.onCompletionInternal|onCompletionInternal(kotlin.Any?){}[0]
    open fun onStart() // kotlinhax.shadowroutines/JobSupport.onStart|onStart(){}[0]
    open fun toString(): kotlin/String // kotlinhax.shadowroutines/JobSupport.toString|toString(){}[0]
}

final object kotlinhax.shadowroutines/Dispatchers { // kotlinhax.shadowroutines/Dispatchers|null[0]
    final val Default // kotlinhax.shadowroutines/Dispatchers.Default|{}Default[0]
        final fun <get-Default>(): kotlinhax.shadowroutines/CoroutineDispatcher // kotlinhax.shadowroutines/Dispatchers.Default.<get-Default>|<get-Default>(){}[0]
    final val Main // kotlinhax.shadowroutines/Dispatchers.Main|{}Main[0]
        final fun <get-Main>(): kotlinhax.shadowroutines/MainCoroutineDispatcher // kotlinhax.shadowroutines/Dispatchers.Main.<get-Main>|<get-Main>(){}[0]
    final val Unconfined // kotlinhax.shadowroutines/Dispatchers.Unconfined|{}Unconfined[0]
        final fun <get-Unconfined>(): kotlinhax.shadowroutines/CoroutineDispatcher // kotlinhax.shadowroutines/Dispatchers.Unconfined.<get-Unconfined>|<get-Unconfined>(){}[0]

    final fun injectMain(kotlinhax.shadowroutines/MainCoroutineDispatcher) // kotlinhax.shadowroutines/Dispatchers.injectMain|injectMain(kotlinhax.shadowroutines.MainCoroutineDispatcher){}[0]
}

final object kotlinhax.shadowroutines/GlobalScope : kotlinhax.shadowroutines/CoroutineScope { // kotlinhax.shadowroutines/GlobalScope|null[0]
    final val coroutineContext // kotlinhax.shadowroutines/GlobalScope.coroutineContext|{}coroutineContext[0]
        final fun <get-coroutineContext>(): kotlin.coroutines/CoroutineContext // kotlinhax.shadowroutines/GlobalScope.coroutineContext.<get-coroutineContext>|<get-coroutineContext>(){}[0]
}

final object kotlinhax.shadowroutines/NonCancellable : kotlin.coroutines/AbstractCoroutineContextElement, kotlinhax.shadowroutines/Job { // kotlinhax.shadowroutines/NonCancellable|null[0]
    final val children // kotlinhax.shadowroutines/NonCancellable.children|{}children[0]
        final fun <get-children>(): kotlin.sequences/Sequence<kotlinhax.shadowroutines/Job> // kotlinhax.shadowroutines/NonCancellable.children.<get-children>|<get-children>(){}[0]
    final val isActive // kotlinhax.shadowroutines/NonCancellable.isActive|{}isActive[0]
        final fun <get-isActive>(): kotlin/Boolean // kotlinhax.shadowroutines/NonCancellable.isActive.<get-isActive>|<get-isActive>(){}[0]
    final val isCancelled // kotlinhax.shadowroutines/NonCancellable.isCancelled|{}isCancelled[0]
        final fun <get-isCancelled>(): kotlin/Boolean // kotlinhax.shadowroutines/NonCancellable.isCancelled.<get-isCancelled>|<get-isCancelled>(){}[0]
    final val isCompleted // kotlinhax.shadowroutines/NonCancellable.isCompleted|{}isCompleted[0]
        final fun <get-isCompleted>(): kotlin/Boolean // kotlinhax.shadowroutines/NonCancellable.isCompleted.<get-isCompleted>|<get-isCompleted>(){}[0]
    final val onJoin // kotlinhax.shadowroutines/NonCancellable.onJoin|{}onJoin[0]
        final fun <get-onJoin>(): kotlinhax.shadowroutines.selects/SelectClause0 // kotlinhax.shadowroutines/NonCancellable.onJoin.<get-onJoin>|<get-onJoin>(){}[0]
    final val parent // kotlinhax.shadowroutines/NonCancellable.parent|{}parent[0]
        final fun <get-parent>(): kotlinhax.shadowroutines/Job? // kotlinhax.shadowroutines/NonCancellable.parent.<get-parent>|<get-parent>(){}[0]

    final fun attachChild(kotlinhax.shadowroutines/ChildJob): kotlinhax.shadowroutines/ChildHandle // kotlinhax.shadowroutines/NonCancellable.attachChild|attachChild(kotlinhax.shadowroutines.ChildJob){}[0]
    final fun cancel(kotlin.coroutines.cancellation/CancellationException?) // kotlinhax.shadowroutines/NonCancellable.cancel|cancel(kotlin.coroutines.cancellation.CancellationException?){}[0]
    final fun cancel(kotlin/Throwable?): kotlin/Boolean // kotlinhax.shadowroutines/NonCancellable.cancel|cancel(kotlin.Throwable?){}[0]
    final fun getCancellationException(): kotlin.coroutines.cancellation/CancellationException // kotlinhax.shadowroutines/NonCancellable.getCancellationException|getCancellationException(){}[0]
    final fun invokeOnCompletion(kotlin/Boolean, kotlin/Boolean, kotlin/Function1<kotlin/Throwable?, kotlin/Unit>): kotlinhax.shadowroutines/DisposableHandle // kotlinhax.shadowroutines/NonCancellable.invokeOnCompletion|invokeOnCompletion(kotlin.Boolean;kotlin.Boolean;kotlin.Function1<kotlin.Throwable?,kotlin.Unit>){}[0]
    final fun invokeOnCompletion(kotlin/Function1<kotlin/Throwable?, kotlin/Unit>): kotlinhax.shadowroutines/DisposableHandle // kotlinhax.shadowroutines/NonCancellable.invokeOnCompletion|invokeOnCompletion(kotlin.Function1<kotlin.Throwable?,kotlin.Unit>){}[0]
    final fun start(): kotlin/Boolean // kotlinhax.shadowroutines/NonCancellable.start|start(){}[0]
    final fun toString(): kotlin/String // kotlinhax.shadowroutines/NonCancellable.toString|toString(){}[0]
    final suspend fun join() // kotlinhax.shadowroutines/NonCancellable.join|join(){}[0]
}

final object kotlinhax.shadowroutines/NonDisposableHandle : kotlinhax.shadowroutines/ChildHandle, kotlinhax.shadowroutines/DisposableHandle { // kotlinhax.shadowroutines/NonDisposableHandle|null[0]
    final val parent // kotlinhax.shadowroutines/NonDisposableHandle.parent|{}parent[0]
        final fun <get-parent>(): kotlinhax.shadowroutines/Job? // kotlinhax.shadowroutines/NonDisposableHandle.parent.<get-parent>|<get-parent>(){}[0]

    final fun childCancelled(kotlin/Throwable): kotlin/Boolean // kotlinhax.shadowroutines/NonDisposableHandle.childCancelled|childCancelled(kotlin.Throwable){}[0]
    final fun dispose() // kotlinhax.shadowroutines/NonDisposableHandle.dispose|dispose(){}[0]
    final fun toString(): kotlin/String // kotlinhax.shadowroutines/NonDisposableHandle.toString|toString(){}[0]
}

final const val kotlinhax.shadowroutines.flow/DEFAULT_CONCURRENCY_PROPERTY_NAME // kotlinhax.shadowroutines.flow/DEFAULT_CONCURRENCY_PROPERTY_NAME|{}DEFAULT_CONCURRENCY_PROPERTY_NAME[0]
    final fun <get-DEFAULT_CONCURRENCY_PROPERTY_NAME>(): kotlin/String // kotlinhax.shadowroutines.flow/DEFAULT_CONCURRENCY_PROPERTY_NAME.<get-DEFAULT_CONCURRENCY_PROPERTY_NAME>|<get-DEFAULT_CONCURRENCY_PROPERTY_NAME>(){}[0]
final const val kotlinhax.shadowroutines/MODE_CANCELLABLE // kotlinhax.shadowroutines/MODE_CANCELLABLE|{}MODE_CANCELLABLE[0]
    final fun <get-MODE_CANCELLABLE>(): kotlin/Int // kotlinhax.shadowroutines/MODE_CANCELLABLE.<get-MODE_CANCELLABLE>|<get-MODE_CANCELLABLE>(){}[0]

final val kotlinhax.shadowroutines.flow/DEFAULT_CONCURRENCY // kotlinhax.shadowroutines.flow/DEFAULT_CONCURRENCY|{}DEFAULT_CONCURRENCY[0]
    final fun <get-DEFAULT_CONCURRENCY>(): kotlin/Int // kotlinhax.shadowroutines.flow/DEFAULT_CONCURRENCY.<get-DEFAULT_CONCURRENCY>|<get-DEFAULT_CONCURRENCY>(){}[0]
final val kotlinhax.shadowroutines.flow/coroutineContext // kotlinhax.shadowroutines.flow/coroutineContext|@kotlinhax.shadowroutines.flow.FlowCollector<*>{}coroutineContext[0]
    final fun (kotlinhax.shadowroutines.flow/FlowCollector<*>).<get-coroutineContext>(): kotlin.coroutines/CoroutineContext // kotlinhax.shadowroutines.flow/coroutineContext.<get-coroutineContext>|<get-coroutineContext>@kotlinhax.shadowroutines.flow.FlowCollector<*>(){}[0]
final val kotlinhax.shadowroutines.flow/isActive // kotlinhax.shadowroutines.flow/isActive|@kotlinhax.shadowroutines.flow.FlowCollector<*>{}isActive[0]
    final fun (kotlinhax.shadowroutines.flow/FlowCollector<*>).<get-isActive>(): kotlin/Boolean // kotlinhax.shadowroutines.flow/isActive.<get-isActive>|<get-isActive>@kotlinhax.shadowroutines.flow.FlowCollector<*>(){}[0]
final val kotlinhax.shadowroutines/DefaultDelay // kotlinhax.shadowroutines/DefaultDelay|{}DefaultDelay[0]
    final fun <get-DefaultDelay>(): kotlinhax.shadowroutines/Delay // kotlinhax.shadowroutines/DefaultDelay.<get-DefaultDelay>|<get-DefaultDelay>(){}[0]
final val kotlinhax.shadowroutines/isActive // kotlinhax.shadowroutines/isActive|@kotlin.coroutines.CoroutineContext{}isActive[0]
    final fun (kotlin.coroutines/CoroutineContext).<get-isActive>(): kotlin/Boolean // kotlinhax.shadowroutines/isActive.<get-isActive>|<get-isActive>@kotlin.coroutines.CoroutineContext(){}[0]
final val kotlinhax.shadowroutines/isActive // kotlinhax.shadowroutines/isActive|@kotlinhax.shadowroutines.CoroutineScope{}isActive[0]
    final fun (kotlinhax.shadowroutines/CoroutineScope).<get-isActive>(): kotlin/Boolean // kotlinhax.shadowroutines/isActive.<get-isActive>|<get-isActive>@kotlinhax.shadowroutines.CoroutineScope(){}[0]
final val kotlinhax.shadowroutines/job // kotlinhax.shadowroutines/job|@kotlin.coroutines.CoroutineContext{}job[0]
    final fun (kotlin.coroutines/CoroutineContext).<get-job>(): kotlinhax.shadowroutines/Job // kotlinhax.shadowroutines/job.<get-job>|<get-job>@kotlin.coroutines.CoroutineContext(){}[0]

final fun (kotlin.coroutines/CoroutineContext).kotlinhax.shadowroutines/cancel() // kotlinhax.shadowroutines/cancel|cancel@kotlin.coroutines.CoroutineContext(){}[0]
final fun (kotlin.coroutines/CoroutineContext).kotlinhax.shadowroutines/cancel(kotlin.coroutines.cancellation/CancellationException? = ...) // kotlinhax.shadowroutines/cancel|cancel@kotlin.coroutines.CoroutineContext(kotlin.coroutines.cancellation.CancellationException?){}[0]
final fun (kotlin.coroutines/CoroutineContext).kotlinhax.shadowroutines/cancel(kotlin/Throwable? = ...): kotlin/Boolean // kotlinhax.shadowroutines/cancel|cancel@kotlin.coroutines.CoroutineContext(kotlin.Throwable?){}[0]
final fun (kotlin.coroutines/CoroutineContext).kotlinhax.shadowroutines/cancelChildren() // kotlinhax.shadowroutines/cancelChildren|cancelChildren@kotlin.coroutines.CoroutineContext(){}[0]
final fun (kotlin.coroutines/CoroutineContext).kotlinhax.shadowroutines/cancelChildren(kotlin.coroutines.cancellation/CancellationException? = ...) // kotlinhax.shadowroutines/cancelChildren|cancelChildren@kotlin.coroutines.CoroutineContext(kotlin.coroutines.cancellation.CancellationException?){}[0]
final fun (kotlin.coroutines/CoroutineContext).kotlinhax.shadowroutines/cancelChildren(kotlin/Throwable? = ...) // kotlinhax.shadowroutines/cancelChildren|cancelChildren@kotlin.coroutines.CoroutineContext(kotlin.Throwable?){}[0]
final fun (kotlin.coroutines/CoroutineContext).kotlinhax.shadowroutines/ensureActive() // kotlinhax.shadowroutines/ensureActive|ensureActive@kotlin.coroutines.CoroutineContext(){}[0]
final fun (kotlin.coroutines/CoroutineContext).kotlinhax.shadowroutines/newCoroutineContext(kotlin.coroutines/CoroutineContext): kotlin.coroutines/CoroutineContext // kotlinhax.shadowroutines/newCoroutineContext|newCoroutineContext@kotlin.coroutines.CoroutineContext(kotlin.coroutines.CoroutineContext){}[0]
final fun (kotlin.ranges/IntRange).kotlinhax.shadowroutines.flow/asFlow(): kotlinhax.shadowroutines.flow/Flow<kotlin/Int> // kotlinhax.shadowroutines.flow/asFlow|asFlow@kotlin.ranges.IntRange(){}[0]
final fun (kotlin.ranges/LongRange).kotlinhax.shadowroutines.flow/asFlow(): kotlinhax.shadowroutines.flow/Flow<kotlin/Long> // kotlinhax.shadowroutines.flow/asFlow|asFlow@kotlin.ranges.LongRange(){}[0]
final fun (kotlin/IntArray).kotlinhax.shadowroutines.flow/asFlow(): kotlinhax.shadowroutines.flow/Flow<kotlin/Int> // kotlinhax.shadowroutines.flow/asFlow|asFlow@kotlin.IntArray(){}[0]
final fun (kotlin/LongArray).kotlinhax.shadowroutines.flow/asFlow(): kotlinhax.shadowroutines.flow/Flow<kotlin/Long> // kotlinhax.shadowroutines.flow/asFlow|asFlow@kotlin.LongArray(){}[0]
final fun (kotlinhax.shadowroutines.channels/ReceiveChannel<*>).kotlinhax.shadowroutines.channels/cancelConsumed(kotlin/Throwable?) // kotlinhax.shadowroutines.channels/cancelConsumed|cancelConsumed@kotlinhax.shadowroutines.channels.ReceiveChannel<*>(kotlin.Throwable?){}[0]
final fun (kotlinhax.shadowroutines.channels/ReceiveChannel<*>).kotlinhax.shadowroutines.channels/consumes(): kotlin/Function1<kotlin/Throwable?, kotlin/Unit> // kotlinhax.shadowroutines.channels/consumes|consumes@kotlinhax.shadowroutines.channels.ReceiveChannel<*>(){}[0]
final fun (kotlinhax.shadowroutines.flow/FlowCollector<*>).kotlinhax.shadowroutines.flow/cancel(kotlin.coroutines.cancellation/CancellationException? = ...) // kotlinhax.shadowroutines.flow/cancel|cancel@kotlinhax.shadowroutines.flow.FlowCollector<*>(kotlin.coroutines.cancellation.CancellationException?){}[0]
final fun (kotlinhax.shadowroutines.flow/SharingStarted.Companion).kotlinhax.shadowroutines.flow/WhileSubscribed(kotlin.time/Duration = ..., kotlin.time/Duration = ...): kotlinhax.shadowroutines.flow/SharingStarted // kotlinhax.shadowroutines.flow/WhileSubscribed|WhileSubscribed@kotlinhax.shadowroutines.flow.SharingStarted.Companion(kotlin.time.Duration;kotlin.time.Duration){}[0]
final fun (kotlinhax.shadowroutines/CancellableContinuation<*>).kotlinhax.shadowroutines/disposeOnCancellation(kotlinhax.shadowroutines/DisposableHandle) // kotlinhax.shadowroutines/disposeOnCancellation|disposeOnCancellation@kotlinhax.shadowroutines.CancellableContinuation<*>(kotlinhax.shadowroutines.DisposableHandle){}[0]
final fun (kotlinhax.shadowroutines/CoroutineScope).kotlinhax.shadowroutines/cancel(kotlin.coroutines.cancellation/CancellationException? = ...) // kotlinhax.shadowroutines/cancel|cancel@kotlinhax.shadowroutines.CoroutineScope(kotlin.coroutines.cancellation.CancellationException?){}[0]
final fun (kotlinhax.shadowroutines/CoroutineScope).kotlinhax.shadowroutines/cancel(kotlin/String, kotlin/Throwable? = ...) // kotlinhax.shadowroutines/cancel|cancel@kotlinhax.shadowroutines.CoroutineScope(kotlin.String;kotlin.Throwable?){}[0]
final fun (kotlinhax.shadowroutines/CoroutineScope).kotlinhax.shadowroutines/ensureActive() // kotlinhax.shadowroutines/ensureActive|ensureActive@kotlinhax.shadowroutines.CoroutineScope(){}[0]
final fun (kotlinhax.shadowroutines/CoroutineScope).kotlinhax.shadowroutines/launch(kotlin.coroutines/CoroutineContext = ..., kotlinhax.shadowroutines/CoroutineStart = ..., kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines/CoroutineScope, kotlin/Unit>): kotlinhax.shadowroutines/Job // kotlinhax.shadowroutines/launch|launch@kotlinhax.shadowroutines.CoroutineScope(kotlin.coroutines.CoroutineContext;kotlinhax.shadowroutines.CoroutineStart;kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.CoroutineScope,kotlin.Unit>){}[0]
final fun (kotlinhax.shadowroutines/CoroutineScope).kotlinhax.shadowroutines/newCoroutineContext(kotlin.coroutines/CoroutineContext): kotlin.coroutines/CoroutineContext // kotlinhax.shadowroutines/newCoroutineContext|newCoroutineContext@kotlinhax.shadowroutines.CoroutineScope(kotlin.coroutines.CoroutineContext){}[0]
final fun (kotlinhax.shadowroutines/CoroutineScope).kotlinhax.shadowroutines/plus(kotlin.coroutines/CoroutineContext): kotlinhax.shadowroutines/CoroutineScope // kotlinhax.shadowroutines/plus|plus@kotlinhax.shadowroutines.CoroutineScope(kotlin.coroutines.CoroutineContext){}[0]
final fun (kotlinhax.shadowroutines/Job).kotlinhax.shadowroutines/cancel(kotlin/String, kotlin/Throwable? = ...) // kotlinhax.shadowroutines/cancel|cancel@kotlinhax.shadowroutines.Job(kotlin.String;kotlin.Throwable?){}[0]
final fun (kotlinhax.shadowroutines/Job).kotlinhax.shadowroutines/cancelChildren() // kotlinhax.shadowroutines/cancelChildren|cancelChildren@kotlinhax.shadowroutines.Job(){}[0]
final fun (kotlinhax.shadowroutines/Job).kotlinhax.shadowroutines/cancelChildren(kotlin.coroutines.cancellation/CancellationException? = ...) // kotlinhax.shadowroutines/cancelChildren|cancelChildren@kotlinhax.shadowroutines.Job(kotlin.coroutines.cancellation.CancellationException?){}[0]
final fun (kotlinhax.shadowroutines/Job).kotlinhax.shadowroutines/cancelChildren(kotlin/Throwable? = ...) // kotlinhax.shadowroutines/cancelChildren|cancelChildren@kotlinhax.shadowroutines.Job(kotlin.Throwable?){}[0]
final fun (kotlinhax.shadowroutines/Job).kotlinhax.shadowroutines/ensureActive() // kotlinhax.shadowroutines/ensureActive|ensureActive@kotlinhax.shadowroutines.Job(){}[0]
final fun <#A: kotlin/Any> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/onReceiveOrNull(): kotlinhax.shadowroutines.selects/SelectClause1<#A?> // kotlinhax.shadowroutines.channels/onReceiveOrNull|onReceiveOrNull@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(){0§<kotlin.Any>}[0]
final fun <#A: kotlin/Any> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A?>).kotlinhax.shadowroutines.channels/filterNotNull(): kotlinhax.shadowroutines.channels/ReceiveChannel<#A> // kotlinhax.shadowroutines.channels/filterNotNull|filterNotNull@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0?>(){0§<kotlin.Any>}[0]
final fun <#A: kotlin/Any> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A?>).kotlinhax.shadowroutines.channels/requireNoNulls(): kotlinhax.shadowroutines.channels/ReceiveChannel<#A> // kotlinhax.shadowroutines.channels/requireNoNulls|requireNoNulls@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0?>(){0§<kotlin.Any>}[0]
final fun <#A: kotlin/Any> (kotlinhax.shadowroutines.flow/Flow<#A?>).kotlinhax.shadowroutines.flow/filterNotNull(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/filterNotNull|filterNotNull@kotlinhax.shadowroutines.flow.Flow<0:0?>(){0§<kotlin.Any>}[0]
final fun <#A: kotlin/Any> (kotlinhax.shadowroutines.flow/Flow<*>).kotlinhax.shadowroutines.flow/filterIsInstance(kotlin.reflect/KClass<#A>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/filterIsInstance|filterIsInstance@kotlinhax.shadowroutines.flow.Flow<*>(kotlin.reflect.KClass<0:0>){0§<kotlin.Any>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/mapIndexedNotNull(kotlin.coroutines/CoroutineContext = ..., kotlin.coroutines/SuspendFunction2<kotlin/Int, #A, #B?>): kotlinhax.shadowroutines.channels/ReceiveChannel<#B> // kotlinhax.shadowroutines.channels/mapIndexedNotNull|mapIndexedNotNull@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlin.coroutines.CoroutineContext;kotlin.coroutines.SuspendFunction2<kotlin.Int,0:0,0:1?>){0§<kotlin.Any?>;1§<kotlin.Any>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/mapNotNull(kotlin.coroutines/CoroutineContext = ..., kotlin.coroutines/SuspendFunction1<#A, #B?>): kotlinhax.shadowroutines.channels/ReceiveChannel<#B> // kotlinhax.shadowroutines.channels/mapNotNull|mapNotNull@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlin.coroutines.CoroutineContext;kotlin.coroutines.SuspendFunction1<0:0,0:1?>){0§<kotlin.Any?>;1§<kotlin.Any>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?, #E: kotlin/Any?, #F: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/combineLatest(kotlinhax.shadowroutines.flow/Flow<#B>, kotlinhax.shadowroutines.flow/Flow<#C>, kotlinhax.shadowroutines.flow/Flow<#D>, kotlinhax.shadowroutines.flow/Flow<#E>, kotlin.coroutines/SuspendFunction5<#A, #B, #C, #D, #E, #F>): kotlinhax.shadowroutines.flow/Flow<#F> // kotlinhax.shadowroutines.flow/combineLatest|combineLatest@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlinhax.shadowroutines.flow.Flow<0:1>;kotlinhax.shadowroutines.flow.Flow<0:2>;kotlinhax.shadowroutines.flow.Flow<0:3>;kotlinhax.shadowroutines.flow.Flow<0:4>;kotlin.coroutines.SuspendFunction5<0:0,0:1,0:2,0:3,0:4,0:5>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>;5§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?, #E: kotlin/Any?, #F: kotlin/Any?> kotlinhax.shadowroutines.flow/combine(kotlinhax.shadowroutines.flow/Flow<#A>, kotlinhax.shadowroutines.flow/Flow<#B>, kotlinhax.shadowroutines.flow/Flow<#C>, kotlinhax.shadowroutines.flow/Flow<#D>, kotlinhax.shadowroutines.flow/Flow<#E>, kotlin.coroutines/SuspendFunction5<#A, #B, #C, #D, #E, #F>): kotlinhax.shadowroutines.flow/Flow<#F> // kotlinhax.shadowroutines.flow/combine|combine(kotlinhax.shadowroutines.flow.Flow<0:0>;kotlinhax.shadowroutines.flow.Flow<0:1>;kotlinhax.shadowroutines.flow.Flow<0:2>;kotlinhax.shadowroutines.flow.Flow<0:3>;kotlinhax.shadowroutines.flow.Flow<0:4>;kotlin.coroutines.SuspendFunction5<0:0,0:1,0:2,0:3,0:4,0:5>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>;5§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?, #E: kotlin/Any?, #F: kotlin/Any?> kotlinhax.shadowroutines.flow/combineTransform(kotlinhax.shadowroutines.flow/Flow<#A>, kotlinhax.shadowroutines.flow/Flow<#B>, kotlinhax.shadowroutines.flow/Flow<#C>, kotlinhax.shadowroutines.flow/Flow<#D>, kotlinhax.shadowroutines.flow/Flow<#E>, kotlin.coroutines/SuspendFunction6<kotlinhax.shadowroutines.flow/FlowCollector<#F>, #A, #B, #C, #D, #E, kotlin/Unit>): kotlinhax.shadowroutines.flow/Flow<#F> // kotlinhax.shadowroutines.flow/combineTransform|combineTransform(kotlinhax.shadowroutines.flow.Flow<0:0>;kotlinhax.shadowroutines.flow.Flow<0:1>;kotlinhax.shadowroutines.flow.Flow<0:2>;kotlinhax.shadowroutines.flow.Flow<0:3>;kotlinhax.shadowroutines.flow.Flow<0:4>;kotlin.coroutines.SuspendFunction6<kotlinhax.shadowroutines.flow.FlowCollector<0:5>,0:0,0:1,0:2,0:3,0:4,kotlin.Unit>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>;5§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?, #E: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/combineLatest(kotlinhax.shadowroutines.flow/Flow<#B>, kotlinhax.shadowroutines.flow/Flow<#C>, kotlinhax.shadowroutines.flow/Flow<#D>, kotlin.coroutines/SuspendFunction4<#A, #B, #C, #D, #E>): kotlinhax.shadowroutines.flow/Flow<#E> // kotlinhax.shadowroutines.flow/combineLatest|combineLatest@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlinhax.shadowroutines.flow.Flow<0:1>;kotlinhax.shadowroutines.flow.Flow<0:2>;kotlinhax.shadowroutines.flow.Flow<0:3>;kotlin.coroutines.SuspendFunction4<0:0,0:1,0:2,0:3,0:4>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?, #E: kotlin/Any?> kotlinhax.shadowroutines.flow/combine(kotlinhax.shadowroutines.flow/Flow<#A>, kotlinhax.shadowroutines.flow/Flow<#B>, kotlinhax.shadowroutines.flow/Flow<#C>, kotlinhax.shadowroutines.flow/Flow<#D>, kotlin.coroutines/SuspendFunction4<#A, #B, #C, #D, #E>): kotlinhax.shadowroutines.flow/Flow<#E> // kotlinhax.shadowroutines.flow/combine|combine(kotlinhax.shadowroutines.flow.Flow<0:0>;kotlinhax.shadowroutines.flow.Flow<0:1>;kotlinhax.shadowroutines.flow.Flow<0:2>;kotlinhax.shadowroutines.flow.Flow<0:3>;kotlin.coroutines.SuspendFunction4<0:0,0:1,0:2,0:3,0:4>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?, #E: kotlin/Any?> kotlinhax.shadowroutines.flow/combineTransform(kotlinhax.shadowroutines.flow/Flow<#A>, kotlinhax.shadowroutines.flow/Flow<#B>, kotlinhax.shadowroutines.flow/Flow<#C>, kotlinhax.shadowroutines.flow/Flow<#D>, kotlin.coroutines/SuspendFunction5<kotlinhax.shadowroutines.flow/FlowCollector<#E>, #A, #B, #C, #D, kotlin/Unit>): kotlinhax.shadowroutines.flow/Flow<#E> // kotlinhax.shadowroutines.flow/combineTransform|combineTransform(kotlinhax.shadowroutines.flow.Flow<0:0>;kotlinhax.shadowroutines.flow.Flow<0:1>;kotlinhax.shadowroutines.flow.Flow<0:2>;kotlinhax.shadowroutines.flow.Flow<0:3>;kotlin.coroutines.SuspendFunction5<kotlinhax.shadowroutines.flow.FlowCollector<0:4>,0:0,0:1,0:2,0:3,kotlin.Unit>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/combineLatest(kotlinhax.shadowroutines.flow/Flow<#B>, kotlinhax.shadowroutines.flow/Flow<#C>, kotlin.coroutines/SuspendFunction3<#A, #B, #C, #D>): kotlinhax.shadowroutines.flow/Flow<#D> // kotlinhax.shadowroutines.flow/combineLatest|combineLatest@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlinhax.shadowroutines.flow.Flow<0:1>;kotlinhax.shadowroutines.flow.Flow<0:2>;kotlin.coroutines.SuspendFunction3<0:0,0:1,0:2,0:3>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> kotlinhax.shadowroutines.flow/combine(kotlinhax.shadowroutines.flow/Flow<#A>, kotlinhax.shadowroutines.flow/Flow<#B>, kotlinhax.shadowroutines.flow/Flow<#C>, kotlin.coroutines/SuspendFunction3<#A, #B, #C, #D>): kotlinhax.shadowroutines.flow/Flow<#D> // kotlinhax.shadowroutines.flow/combine|combine(kotlinhax.shadowroutines.flow.Flow<0:0>;kotlinhax.shadowroutines.flow.Flow<0:1>;kotlinhax.shadowroutines.flow.Flow<0:2>;kotlin.coroutines.SuspendFunction3<0:0,0:1,0:2,0:3>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?, #D: kotlin/Any?> kotlinhax.shadowroutines.flow/combineTransform(kotlinhax.shadowroutines.flow/Flow<#A>, kotlinhax.shadowroutines.flow/Flow<#B>, kotlinhax.shadowroutines.flow/Flow<#C>, kotlin.coroutines/SuspendFunction4<kotlinhax.shadowroutines.flow/FlowCollector<#D>, #A, #B, #C, kotlin/Unit>): kotlinhax.shadowroutines.flow/Flow<#D> // kotlinhax.shadowroutines.flow/combineTransform|combineTransform(kotlinhax.shadowroutines.flow.Flow<0:0>;kotlinhax.shadowroutines.flow.Flow<0:1>;kotlinhax.shadowroutines.flow.Flow<0:2>;kotlin.coroutines.SuspendFunction4<kotlinhax.shadowroutines.flow.FlowCollector<0:3>,0:0,0:1,0:2,kotlin.Unit>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/zip(kotlinhax.shadowroutines.channels/ReceiveChannel<#B>, kotlin.coroutines/CoroutineContext = ..., kotlin/Function2<#A, #B, #C>): kotlinhax.shadowroutines.channels/ReceiveChannel<#C> // kotlinhax.shadowroutines.channels/zip|zip@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlinhax.shadowroutines.channels.ReceiveChannel<0:1>;kotlin.coroutines.CoroutineContext;kotlin.Function2<0:0,0:1,0:2>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/combine(kotlinhax.shadowroutines.flow/Flow<#B>, kotlin.coroutines/SuspendFunction2<#A, #B, #C>): kotlinhax.shadowroutines.flow/Flow<#C> // kotlinhax.shadowroutines.flow/combine|combine@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlinhax.shadowroutines.flow.Flow<0:1>;kotlin.coroutines.SuspendFunction2<0:0,0:1,0:2>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/combineLatest(kotlinhax.shadowroutines.flow/Flow<#B>, kotlin.coroutines/SuspendFunction2<#A, #B, #C>): kotlinhax.shadowroutines.flow/Flow<#C> // kotlinhax.shadowroutines.flow/combineLatest|combineLatest@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlinhax.shadowroutines.flow.Flow<0:1>;kotlin.coroutines.SuspendFunction2<0:0,0:1,0:2>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/combineTransform(kotlinhax.shadowroutines.flow/Flow<#B>, kotlin.coroutines/SuspendFunction3<kotlinhax.shadowroutines.flow/FlowCollector<#C>, #A, #B, kotlin/Unit>): kotlinhax.shadowroutines.flow/Flow<#C> // kotlinhax.shadowroutines.flow/combineTransform|combineTransform@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlinhax.shadowroutines.flow.Flow<0:1>;kotlin.coroutines.SuspendFunction3<kotlinhax.shadowroutines.flow.FlowCollector<0:2>,0:0,0:1,kotlin.Unit>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/zip(kotlinhax.shadowroutines.flow/Flow<#B>, kotlin.coroutines/SuspendFunction2<#A, #B, #C>): kotlinhax.shadowroutines.flow/Flow<#C> // kotlinhax.shadowroutines.flow/zip|zip@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlinhax.shadowroutines.flow.Flow<0:1>;kotlin.coroutines.SuspendFunction2<0:0,0:1,0:2>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> kotlinhax.shadowroutines.flow/combine(kotlinhax.shadowroutines.flow/Flow<#A>, kotlinhax.shadowroutines.flow/Flow<#B>, kotlin.coroutines/SuspendFunction2<#A, #B, #C>): kotlinhax.shadowroutines.flow/Flow<#C> // kotlinhax.shadowroutines.flow/combine|combine(kotlinhax.shadowroutines.flow.Flow<0:0>;kotlinhax.shadowroutines.flow.Flow<0:1>;kotlin.coroutines.SuspendFunction2<0:0,0:1,0:2>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin/Any?> kotlinhax.shadowroutines.flow/combineTransform(kotlinhax.shadowroutines.flow/Flow<#A>, kotlinhax.shadowroutines.flow/Flow<#B>, kotlin.coroutines/SuspendFunction3<kotlinhax.shadowroutines.flow/FlowCollector<#C>, #A, #B, kotlin/Unit>): kotlinhax.shadowroutines.flow/Flow<#C> // kotlinhax.shadowroutines.flow/combineTransform|combineTransform(kotlinhax.shadowroutines.flow.Flow<0:0>;kotlinhax.shadowroutines.flow.Flow<0:1>;kotlin.coroutines.SuspendFunction3<kotlinhax.shadowroutines.flow.FlowCollector<0:2>,0:0,0:1,kotlin.Unit>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/distinctBy(kotlin.coroutines/CoroutineContext = ..., kotlin.coroutines/SuspendFunction1<#A, #B>): kotlinhax.shadowroutines.channels/ReceiveChannel<#A> // kotlinhax.shadowroutines.channels/distinctBy|distinctBy@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlin.coroutines.CoroutineContext;kotlin.coroutines.SuspendFunction1<0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/flatMap(kotlin.coroutines/CoroutineContext = ..., kotlin.coroutines/SuspendFunction1<#A, kotlinhax.shadowroutines.channels/ReceiveChannel<#B>>): kotlinhax.shadowroutines.channels/ReceiveChannel<#B> // kotlinhax.shadowroutines.channels/flatMap|flatMap@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlin.coroutines.CoroutineContext;kotlin.coroutines.SuspendFunction1<0:0,kotlinhax.shadowroutines.channels.ReceiveChannel<0:1>>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/map(kotlin.coroutines/CoroutineContext = ..., kotlin.coroutines/SuspendFunction1<#A, #B>): kotlinhax.shadowroutines.channels/ReceiveChannel<#B> // kotlinhax.shadowroutines.channels/map|map@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlin.coroutines.CoroutineContext;kotlin.coroutines.SuspendFunction1<0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/mapIndexed(kotlin.coroutines/CoroutineContext = ..., kotlin.coroutines/SuspendFunction2<kotlin/Int, #A, #B>): kotlinhax.shadowroutines.channels/ReceiveChannel<#B> // kotlinhax.shadowroutines.channels/mapIndexed|mapIndexed@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlin.coroutines.CoroutineContext;kotlin.coroutines.SuspendFunction2<kotlin.Int,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/zip(kotlinhax.shadowroutines.channels/ReceiveChannel<#B>): kotlinhax.shadowroutines.channels/ReceiveChannel<kotlin/Pair<#A, #B>> // kotlinhax.shadowroutines.channels/zip|zip@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlinhax.shadowroutines.channels.ReceiveChannel<0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/compose(kotlin/Function1<kotlinhax.shadowroutines.flow/Flow<#A>, kotlinhax.shadowroutines.flow/Flow<#B>>): kotlinhax.shadowroutines.flow/Flow<#B> // kotlinhax.shadowroutines.flow/compose|compose@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.Function1<kotlinhax.shadowroutines.flow.Flow<0:0>,kotlinhax.shadowroutines.flow.Flow<0:1>>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/concatMap(kotlin/Function1<#A, kotlinhax.shadowroutines.flow/Flow<#B>>): kotlinhax.shadowroutines.flow/Flow<#B> // kotlinhax.shadowroutines.flow/concatMap|concatMap@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.Function1<0:0,kotlinhax.shadowroutines.flow.Flow<0:1>>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/distinctUntilChangedBy(kotlin/Function1<#A, #B>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/distinctUntilChangedBy|distinctUntilChangedBy@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.Function1<0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/flatMap(kotlin.coroutines/SuspendFunction1<#A, kotlinhax.shadowroutines.flow/Flow<#B>>): kotlinhax.shadowroutines.flow/Flow<#B> // kotlinhax.shadowroutines.flow/flatMap|flatMap@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,kotlinhax.shadowroutines.flow.Flow<0:1>>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/flatMapConcat(kotlin.coroutines/SuspendFunction1<#A, kotlinhax.shadowroutines.flow/Flow<#B>>): kotlinhax.shadowroutines.flow/Flow<#B> // kotlinhax.shadowroutines.flow/flatMapConcat|flatMapConcat@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,kotlinhax.shadowroutines.flow.Flow<0:1>>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/flatMapMerge(kotlin/Int = ..., kotlin.coroutines/SuspendFunction1<#A, kotlinhax.shadowroutines.flow/Flow<#B>>): kotlinhax.shadowroutines.flow/Flow<#B> // kotlinhax.shadowroutines.flow/flatMapMerge|flatMapMerge@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.Int;kotlin.coroutines.SuspendFunction1<0:0,kotlinhax.shadowroutines.flow.Flow<0:1>>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/mapLatest(kotlin.coroutines/SuspendFunction1<#A, #B>): kotlinhax.shadowroutines.flow/Flow<#B> // kotlinhax.shadowroutines.flow/mapLatest|mapLatest@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/runningFold(#B, kotlin.coroutines/SuspendFunction2<#B, #A, #B>): kotlinhax.shadowroutines.flow/Flow<#B> // kotlinhax.shadowroutines.flow/runningFold|runningFold@kotlinhax.shadowroutines.flow.Flow<0:0>(0:1;kotlin.coroutines.SuspendFunction2<0:1,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/scan(#B, kotlin.coroutines/SuspendFunction2<#B, #A, #B>): kotlinhax.shadowroutines.flow/Flow<#B> // kotlinhax.shadowroutines.flow/scan|scan@kotlinhax.shadowroutines.flow.Flow<0:0>(0:1;kotlin.coroutines.SuspendFunction2<0:1,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/scanFold(#B, kotlin.coroutines/SuspendFunction2<#B, #A, #B>): kotlinhax.shadowroutines.flow/Flow<#B> // kotlinhax.shadowroutines.flow/scanFold|scanFold@kotlinhax.shadowroutines.flow.Flow<0:0>(0:1;kotlin.coroutines.SuspendFunction2<0:1,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/switchMap(kotlin.coroutines/SuspendFunction1<#A, kotlinhax.shadowroutines.flow/Flow<#B>>): kotlinhax.shadowroutines.flow/Flow<#B> // kotlinhax.shadowroutines.flow/switchMap|switchMap@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,kotlinhax.shadowroutines.flow.Flow<0:1>>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/transformLatest(kotlin.coroutines/SuspendFunction2<kotlinhax.shadowroutines.flow/FlowCollector<#B>, #A, kotlin/Unit>): kotlinhax.shadowroutines.flow/Flow<#B> // kotlinhax.shadowroutines.flow/transformLatest|transformLatest@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction2<kotlinhax.shadowroutines.flow.FlowCollector<0:1>,0:0,kotlin.Unit>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/transformWhile(kotlin.coroutines/SuspendFunction2<kotlinhax.shadowroutines.flow/FlowCollector<#B>, #A, kotlin/Boolean>): kotlinhax.shadowroutines.flow/Flow<#B> // kotlinhax.shadowroutines.flow/transformWhile|transformWhile@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction2<kotlinhax.shadowroutines.flow.FlowCollector<0:1>,0:0,kotlin.Boolean>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlin.collections/Iterable<#A>).kotlinhax.shadowroutines.flow/asFlow(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/asFlow|asFlow@kotlin.collections.Iterable<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlin.collections/Iterable<kotlinhax.shadowroutines.flow/Flow<#A>>).kotlinhax.shadowroutines.flow/merge(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/merge|merge@kotlin.collections.Iterable<kotlinhax.shadowroutines.flow.Flow<0:0>>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlin.collections/Iterator<#A>).kotlinhax.shadowroutines.flow/asFlow(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/asFlow|asFlow@kotlin.collections.Iterator<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlin.coroutines/SuspendFunction0<#A>).kotlinhax.shadowroutines.flow/asFlow(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/asFlow|asFlow@kotlin.coroutines.SuspendFunction0<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlin.coroutines/SuspendFunction0<#A>).kotlinhax.shadowroutines.intrinsics/startCoroutineCancellable(kotlin.coroutines/Continuation<#A>) // kotlinhax.shadowroutines.intrinsics/startCoroutineCancellable|startCoroutineCancellable@kotlin.coroutines.SuspendFunction0<0:0>(kotlin.coroutines.Continuation<0:0>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlin.sequences/Sequence<#A>).kotlinhax.shadowroutines.flow/asFlow(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/asFlow|asFlow@kotlin.sequences.Sequence<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlin/Array<#A>).kotlinhax.shadowroutines.flow/asFlow(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/asFlow|asFlow@kotlin.Array<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlin/Function0<#A>).kotlinhax.shadowroutines.flow/asFlow(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/asFlow|asFlow@kotlin.Function0<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/broadcast(kotlin/Int = ..., kotlinhax.shadowroutines/CoroutineStart = ...): kotlinhax.shadowroutines.channels/BroadcastChannel<#A> // kotlinhax.shadowroutines.channels/broadcast|broadcast@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlin.Int;kotlinhax.shadowroutines.CoroutineStart){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/distinct(): kotlinhax.shadowroutines.channels/ReceiveChannel<#A> // kotlinhax.shadowroutines.channels/distinct|distinct@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/drop(kotlin/Int, kotlin.coroutines/CoroutineContext = ...): kotlinhax.shadowroutines.channels/ReceiveChannel<#A> // kotlinhax.shadowroutines.channels/drop|drop@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlin.Int;kotlin.coroutines.CoroutineContext){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/dropWhile(kotlin.coroutines/CoroutineContext = ..., kotlin.coroutines/SuspendFunction1<#A, kotlin/Boolean>): kotlinhax.shadowroutines.channels/ReceiveChannel<#A> // kotlinhax.shadowroutines.channels/dropWhile|dropWhile@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlin.coroutines.CoroutineContext;kotlin.coroutines.SuspendFunction1<0:0,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/filter(kotlin.coroutines/CoroutineContext = ..., kotlin.coroutines/SuspendFunction1<#A, kotlin/Boolean>): kotlinhax.shadowroutines.channels/ReceiveChannel<#A> // kotlinhax.shadowroutines.channels/filter|filter@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlin.coroutines.CoroutineContext;kotlin.coroutines.SuspendFunction1<0:0,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/filterIndexed(kotlin.coroutines/CoroutineContext = ..., kotlin.coroutines/SuspendFunction2<kotlin/Int, #A, kotlin/Boolean>): kotlinhax.shadowroutines.channels/ReceiveChannel<#A> // kotlinhax.shadowroutines.channels/filterIndexed|filterIndexed@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlin.coroutines.CoroutineContext;kotlin.coroutines.SuspendFunction2<kotlin.Int,0:0,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/filterNot(kotlin.coroutines/CoroutineContext = ..., kotlin.coroutines/SuspendFunction1<#A, kotlin/Boolean>): kotlinhax.shadowroutines.channels/ReceiveChannel<#A> // kotlinhax.shadowroutines.channels/filterNot|filterNot@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlin.coroutines.CoroutineContext;kotlin.coroutines.SuspendFunction1<0:0,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/take(kotlin/Int, kotlin.coroutines/CoroutineContext = ...): kotlinhax.shadowroutines.channels/ReceiveChannel<#A> // kotlinhax.shadowroutines.channels/take|take@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlin.Int;kotlin.coroutines.CoroutineContext){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/takeWhile(kotlin.coroutines/CoroutineContext = ..., kotlin.coroutines/SuspendFunction1<#A, kotlin/Boolean>): kotlinhax.shadowroutines.channels/ReceiveChannel<#A> // kotlinhax.shadowroutines.channels/takeWhile|takeWhile@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlin.coroutines.CoroutineContext;kotlin.coroutines.SuspendFunction1<0:0,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/withIndex(kotlin.coroutines/CoroutineContext = ...): kotlinhax.shadowroutines.channels/ReceiveChannel<kotlin.collections/IndexedValue<#A>> // kotlinhax.shadowroutines.channels/withIndex|withIndex@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlin.coroutines.CoroutineContext){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.flow/consumeAsFlow(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/consumeAsFlow|consumeAsFlow@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.flow/receiveAsFlow(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/receiveAsFlow|receiveAsFlow@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/buffer(kotlin/Int = ...): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/buffer|buffer@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.Int){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/buffer(kotlin/Int = ..., kotlinhax.shadowroutines.channels/BufferOverflow = ...): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/buffer|buffer@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.Int;kotlinhax.shadowroutines.channels.BufferOverflow){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/cache(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/cache|cache@kotlinhax.shadowroutines.flow.Flow<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/cancellable(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/cancellable|cancellable@kotlinhax.shadowroutines.flow.Flow<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/catch(kotlin.coroutines/SuspendFunction2<kotlinhax.shadowroutines.flow/FlowCollector<#A>, kotlin/Throwable, kotlin/Unit>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/catch|catch@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction2<kotlinhax.shadowroutines.flow.FlowCollector<0:0>,kotlin.Throwable,kotlin.Unit>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/chunked(kotlin/Int): kotlinhax.shadowroutines.flow/Flow<kotlin.collections/List<#A>> // kotlinhax.shadowroutines.flow/chunked|chunked@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.Int){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/concatWith(#A): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/concatWith|concatWith@kotlinhax.shadowroutines.flow.Flow<0:0>(0:0){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/concatWith(kotlinhax.shadowroutines.flow/Flow<#A>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/concatWith|concatWith@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlinhax.shadowroutines.flow.Flow<0:0>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/conflate(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/conflate|conflate@kotlinhax.shadowroutines.flow.Flow<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/debounce(kotlin.time/Duration): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/debounce|debounce@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.time.Duration){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/debounce(kotlin/Function1<#A, kotlin.time/Duration>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/debounce|debounce@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.Function1<0:0,kotlin.time.Duration>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/debounce(kotlin/Function1<#A, kotlin/Long>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/debounce|debounce@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.Function1<0:0,kotlin.Long>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/debounce(kotlin/Long): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/debounce|debounce@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.Long){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/delayEach(kotlin/Long): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/delayEach|delayEach@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.Long){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/delayFlow(kotlin/Long): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/delayFlow|delayFlow@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.Long){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/distinctUntilChanged(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/distinctUntilChanged|distinctUntilChanged@kotlinhax.shadowroutines.flow.Flow<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/distinctUntilChanged(kotlin/Function2<#A, #A, kotlin/Boolean>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/distinctUntilChanged|distinctUntilChanged@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.Function2<0:0,0:0,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/drop(kotlin/Int): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/drop|drop@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.Int){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/dropWhile(kotlin.coroutines/SuspendFunction1<#A, kotlin/Boolean>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/dropWhile|dropWhile@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/flowOn(kotlin.coroutines/CoroutineContext): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/flowOn|flowOn@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.CoroutineContext){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/forEach(kotlin.coroutines/SuspendFunction1<#A, kotlin/Unit>) // kotlinhax.shadowroutines.flow/forEach|forEach@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,kotlin.Unit>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/launchIn(kotlinhax.shadowroutines/CoroutineScope): kotlinhax.shadowroutines/Job // kotlinhax.shadowroutines.flow/launchIn|launchIn@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlinhax.shadowroutines.CoroutineScope){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/observeOn(kotlin.coroutines/CoroutineContext): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/observeOn|observeOn@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.CoroutineContext){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/onCompletion(kotlin.coroutines/SuspendFunction2<kotlinhax.shadowroutines.flow/FlowCollector<#A>, kotlin/Throwable?, kotlin/Unit>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/onCompletion|onCompletion@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction2<kotlinhax.shadowroutines.flow.FlowCollector<0:0>,kotlin.Throwable?,kotlin.Unit>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/onEach(kotlin.coroutines/SuspendFunction1<#A, kotlin/Unit>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/onEach|onEach@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,kotlin.Unit>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/onEmpty(kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines.flow/FlowCollector<#A>, kotlin/Unit>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/onEmpty|onEmpty@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.flow.FlowCollector<0:0>,kotlin.Unit>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/onErrorResume(kotlinhax.shadowroutines.flow/Flow<#A>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/onErrorResume|onErrorResume@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlinhax.shadowroutines.flow.Flow<0:0>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/onErrorResumeNext(kotlinhax.shadowroutines.flow/Flow<#A>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/onErrorResumeNext|onErrorResumeNext@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlinhax.shadowroutines.flow.Flow<0:0>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/onErrorReturn(#A): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/onErrorReturn|onErrorReturn@kotlinhax.shadowroutines.flow.Flow<0:0>(0:0){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/onErrorReturn(#A, kotlin/Function1<kotlin/Throwable, kotlin/Boolean> = ...): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/onErrorReturn|onErrorReturn@kotlinhax.shadowroutines.flow.Flow<0:0>(0:0;kotlin.Function1<kotlin.Throwable,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/onStart(kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines.flow/FlowCollector<#A>, kotlin/Unit>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/onStart|onStart@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.flow.FlowCollector<0:0>,kotlin.Unit>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/produceIn(kotlinhax.shadowroutines/CoroutineScope): kotlinhax.shadowroutines.channels/ReceiveChannel<#A> // kotlinhax.shadowroutines.flow/produceIn|produceIn@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlinhax.shadowroutines.CoroutineScope){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/publish(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/publish|publish@kotlinhax.shadowroutines.flow.Flow<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/publish(kotlin/Int): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/publish|publish@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.Int){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/publishOn(kotlin.coroutines/CoroutineContext): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/publishOn|publishOn@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.CoroutineContext){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/replay(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/replay|replay@kotlinhax.shadowroutines.flow.Flow<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/replay(kotlin/Int): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/replay|replay@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.Int){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/retry(kotlin/Long = ..., kotlin.coroutines/SuspendFunction1<kotlin/Throwable, kotlin/Boolean> = ...): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/retry|retry@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.Long;kotlin.coroutines.SuspendFunction1<kotlin.Throwable,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/retryWhen(kotlin.coroutines/SuspendFunction3<kotlinhax.shadowroutines.flow/FlowCollector<#A>, kotlin/Throwable, kotlin/Long, kotlin/Boolean>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/retryWhen|retryWhen@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction3<kotlinhax.shadowroutines.flow.FlowCollector<0:0>,kotlin.Throwable,kotlin.Long,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/runningReduce(kotlin.coroutines/SuspendFunction2<#A, #A, #A>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/runningReduce|runningReduce@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction2<0:0,0:0,0:0>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/sample(kotlin.time/Duration): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/sample|sample@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.time.Duration){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/sample(kotlin/Long): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/sample|sample@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.Long){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/scanReduce(kotlin.coroutines/SuspendFunction2<#A, #A, #A>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/scanReduce|scanReduce@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction2<0:0,0:0,0:0>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/shareIn(kotlinhax.shadowroutines/CoroutineScope, kotlinhax.shadowroutines.flow/SharingStarted, kotlin/Int = ...): kotlinhax.shadowroutines.flow/SharedFlow<#A> // kotlinhax.shadowroutines.flow/shareIn|shareIn@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlinhax.shadowroutines.CoroutineScope;kotlinhax.shadowroutines.flow.SharingStarted;kotlin.Int){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/skip(kotlin/Int): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/skip|skip@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.Int){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/startWith(#A): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/startWith|startWith@kotlinhax.shadowroutines.flow.Flow<0:0>(0:0){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/startWith(kotlinhax.shadowroutines.flow/Flow<#A>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/startWith|startWith@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlinhax.shadowroutines.flow.Flow<0:0>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/stateIn(kotlinhax.shadowroutines/CoroutineScope, kotlinhax.shadowroutines.flow/SharingStarted, #A): kotlinhax.shadowroutines.flow/StateFlow<#A> // kotlinhax.shadowroutines.flow/stateIn|stateIn@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlinhax.shadowroutines.CoroutineScope;kotlinhax.shadowroutines.flow.SharingStarted;0:0){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/subscribe() // kotlinhax.shadowroutines.flow/subscribe|subscribe@kotlinhax.shadowroutines.flow.Flow<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/subscribe(kotlin.coroutines/SuspendFunction1<#A, kotlin/Unit>) // kotlinhax.shadowroutines.flow/subscribe|subscribe@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,kotlin.Unit>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/subscribe(kotlin.coroutines/SuspendFunction1<#A, kotlin/Unit>, kotlin.coroutines/SuspendFunction1<kotlin/Throwable, kotlin/Unit>) // kotlinhax.shadowroutines.flow/subscribe|subscribe@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,kotlin.Unit>;kotlin.coroutines.SuspendFunction1<kotlin.Throwable,kotlin.Unit>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/subscribeOn(kotlin.coroutines/CoroutineContext): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/subscribeOn|subscribeOn@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.CoroutineContext){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/take(kotlin/Int): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/take|take@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.Int){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/takeWhile(kotlin.coroutines/SuspendFunction1<#A, kotlin/Boolean>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/takeWhile|takeWhile@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/timeout(kotlin.time/Duration): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/timeout|timeout@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.time.Duration){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/withIndex(): kotlinhax.shadowroutines.flow/Flow<kotlin.collections/IndexedValue<#A>> // kotlinhax.shadowroutines.flow/withIndex|withIndex@kotlinhax.shadowroutines.flow.Flow<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<kotlinhax.shadowroutines.flow/Flow<#A>>).kotlinhax.shadowroutines.flow/flatten(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/flatten|flatten@kotlinhax.shadowroutines.flow.Flow<kotlinhax.shadowroutines.flow.Flow<0:0>>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<kotlinhax.shadowroutines.flow/Flow<#A>>).kotlinhax.shadowroutines.flow/flattenConcat(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/flattenConcat|flattenConcat@kotlinhax.shadowroutines.flow.Flow<kotlinhax.shadowroutines.flow.Flow<0:0>>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<kotlinhax.shadowroutines.flow/Flow<#A>>).kotlinhax.shadowroutines.flow/flattenMerge(kotlin/Int = ...): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/flattenMerge|flattenMerge@kotlinhax.shadowroutines.flow.Flow<kotlinhax.shadowroutines.flow.Flow<0:0>>(kotlin.Int){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<kotlinhax.shadowroutines.flow/Flow<#A>>).kotlinhax.shadowroutines.flow/merge(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/merge|merge@kotlinhax.shadowroutines.flow.Flow<kotlinhax.shadowroutines.flow.Flow<0:0>>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/MutableSharedFlow<#A>).kotlinhax.shadowroutines.flow/asSharedFlow(): kotlinhax.shadowroutines.flow/SharedFlow<#A> // kotlinhax.shadowroutines.flow/asSharedFlow|asSharedFlow@kotlinhax.shadowroutines.flow.MutableSharedFlow<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/MutableStateFlow<#A>).kotlinhax.shadowroutines.flow/asStateFlow(): kotlinhax.shadowroutines.flow/StateFlow<#A> // kotlinhax.shadowroutines.flow/asStateFlow|asStateFlow@kotlinhax.shadowroutines.flow.MutableStateFlow<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/SharedFlow<#A>).kotlinhax.shadowroutines.flow/cancellable(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/cancellable|cancellable@kotlinhax.shadowroutines.flow.SharedFlow<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/SharedFlow<#A>).kotlinhax.shadowroutines.flow/flowOn(kotlin.coroutines/CoroutineContext): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/flowOn|flowOn@kotlinhax.shadowroutines.flow.SharedFlow<0:0>(kotlin.coroutines.CoroutineContext){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/SharedFlow<#A>).kotlinhax.shadowroutines.flow/onSubscription(kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines.flow/FlowCollector<#A>, kotlin/Unit>): kotlinhax.shadowroutines.flow/SharedFlow<#A> // kotlinhax.shadowroutines.flow/onSubscription|onSubscription@kotlinhax.shadowroutines.flow.SharedFlow<0:0>(kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.flow.FlowCollector<0:0>,kotlin.Unit>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/StateFlow<#A>).kotlinhax.shadowroutines.flow/conflate(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/conflate|conflate@kotlinhax.shadowroutines.flow.StateFlow<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/StateFlow<#A>).kotlinhax.shadowroutines.flow/distinctUntilChanged(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/distinctUntilChanged|distinctUntilChanged@kotlinhax.shadowroutines.flow.StateFlow<0:0>(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.selects/SelectBuilder<#A>).kotlinhax.shadowroutines.selects/onTimeout(kotlin.time/Duration, kotlin.coroutines/SuspendFunction0<#A>) // kotlinhax.shadowroutines.selects/onTimeout|onTimeout@kotlinhax.shadowroutines.selects.SelectBuilder<0:0>(kotlin.time.Duration;kotlin.coroutines.SuspendFunction0<0:0>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.selects/SelectBuilder<#A>).kotlinhax.shadowroutines.selects/onTimeout(kotlin/Long, kotlin.coroutines/SuspendFunction0<#A>) // kotlinhax.shadowroutines.selects/onTimeout|onTimeout@kotlinhax.shadowroutines.selects.SelectBuilder<0:0>(kotlin.Long;kotlin.coroutines.SuspendFunction0<0:0>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines/CompletableDeferred<#A>).kotlinhax.shadowroutines/completeWith(kotlin/Result<#A>): kotlin/Boolean // kotlinhax.shadowroutines/completeWith|completeWith@kotlinhax.shadowroutines.CompletableDeferred<0:0>(kotlin.Result<0:0>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines/CoroutineScope).kotlinhax.shadowroutines.channels/broadcast(kotlin.coroutines/CoroutineContext = ..., kotlin/Int = ..., kotlinhax.shadowroutines/CoroutineStart = ..., kotlin/Function1<kotlin/Throwable?, kotlin/Unit>? = ..., kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines.channels/ProducerScope<#A>, kotlin/Unit>): kotlinhax.shadowroutines.channels/BroadcastChannel<#A> // kotlinhax.shadowroutines.channels/broadcast|broadcast@kotlinhax.shadowroutines.CoroutineScope(kotlin.coroutines.CoroutineContext;kotlin.Int;kotlinhax.shadowroutines.CoroutineStart;kotlin.Function1<kotlin.Throwable?,kotlin.Unit>?;kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.channels.ProducerScope<0:0>,kotlin.Unit>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines/CoroutineScope).kotlinhax.shadowroutines.channels/produce(kotlin.coroutines/CoroutineContext = ..., kotlin/Int = ..., kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines.channels/ProducerScope<#A>, kotlin/Unit>): kotlinhax.shadowroutines.channels/ReceiveChannel<#A> // kotlinhax.shadowroutines.channels/produce|produce@kotlinhax.shadowroutines.CoroutineScope(kotlin.coroutines.CoroutineContext;kotlin.Int;kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.channels.ProducerScope<0:0>,kotlin.Unit>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines/CoroutineScope).kotlinhax.shadowroutines.channels/produce(kotlin.coroutines/CoroutineContext = ..., kotlin/Int = ..., kotlinhax.shadowroutines/CoroutineStart = ..., kotlin/Function1<kotlin/Throwable?, kotlin/Unit>? = ..., kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines.channels/ProducerScope<#A>, kotlin/Unit>): kotlinhax.shadowroutines.channels/ReceiveChannel<#A> // kotlinhax.shadowroutines.channels/produce|produce@kotlinhax.shadowroutines.CoroutineScope(kotlin.coroutines.CoroutineContext;kotlin.Int;kotlinhax.shadowroutines.CoroutineStart;kotlin.Function1<kotlin.Throwable?,kotlin.Unit>?;kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.channels.ProducerScope<0:0>,kotlin.Unit>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines/CoroutineScope).kotlinhax.shadowroutines/async(kotlin.coroutines/CoroutineContext = ..., kotlinhax.shadowroutines/CoroutineStart = ..., kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines/CoroutineScope, #A>): kotlinhax.shadowroutines/Deferred<#A> // kotlinhax.shadowroutines/async|async@kotlinhax.shadowroutines.CoroutineScope(kotlin.coroutines.CoroutineContext;kotlinhax.shadowroutines.CoroutineStart;kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.CoroutineScope,0:0>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> kotlinhax.shadowroutines.channels/BroadcastChannel(kotlin/Int): kotlinhax.shadowroutines.channels/BroadcastChannel<#A> // kotlinhax.shadowroutines.channels/BroadcastChannel|BroadcastChannel(kotlin.Int){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> kotlinhax.shadowroutines.channels/Channel(kotlin/Int = ...): kotlinhax.shadowroutines.channels/Channel<#A> // kotlinhax.shadowroutines.channels/Channel|Channel(kotlin.Int){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> kotlinhax.shadowroutines.channels/Channel(kotlin/Int = ..., kotlinhax.shadowroutines.channels/BufferOverflow = ..., kotlin/Function1<#A, kotlin/Unit>? = ...): kotlinhax.shadowroutines.channels/Channel<#A> // kotlinhax.shadowroutines.channels/Channel|Channel(kotlin.Int;kotlinhax.shadowroutines.channels.BufferOverflow;kotlin.Function1<0:0,kotlin.Unit>?){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> kotlinhax.shadowroutines.flow/MutableSharedFlow(kotlin/Int = ..., kotlin/Int = ..., kotlinhax.shadowroutines.channels/BufferOverflow = ...): kotlinhax.shadowroutines.flow/MutableSharedFlow<#A> // kotlinhax.shadowroutines.flow/MutableSharedFlow|MutableSharedFlow(kotlin.Int;kotlin.Int;kotlinhax.shadowroutines.channels.BufferOverflow){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> kotlinhax.shadowroutines.flow/MutableStateFlow(#A): kotlinhax.shadowroutines.flow/MutableStateFlow<#A> // kotlinhax.shadowroutines.flow/MutableStateFlow|MutableStateFlow(0:0){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> kotlinhax.shadowroutines.flow/callbackFlow(kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines.channels/ProducerScope<#A>, kotlin/Unit>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/callbackFlow|callbackFlow(kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.channels.ProducerScope<0:0>,kotlin.Unit>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> kotlinhax.shadowroutines.flow/channelFlow(kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines.channels/ProducerScope<#A>, kotlin/Unit>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/channelFlow|channelFlow(kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.channels.ProducerScope<0:0>,kotlin.Unit>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> kotlinhax.shadowroutines.flow/emptyFlow(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/emptyFlow|emptyFlow(){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> kotlinhax.shadowroutines.flow/flow(kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines.flow/FlowCollector<#A>, kotlin/Unit>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/flow|flow(kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.flow.FlowCollector<0:0>,kotlin.Unit>){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> kotlinhax.shadowroutines.flow/flowOf(#A): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/flowOf|flowOf(0:0){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> kotlinhax.shadowroutines.flow/flowOf(kotlin/Array<out #A>...): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/flowOf|flowOf(kotlin.Array<out|0:0>...){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> kotlinhax.shadowroutines.flow/merge(kotlin/Array<out kotlinhax.shadowroutines.flow/Flow<#A>>...): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/merge|merge(kotlin.Array<out|kotlinhax.shadowroutines.flow.Flow<0:0>>...){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> kotlinhax.shadowroutines/CompletableDeferred(#A): kotlinhax.shadowroutines/CompletableDeferred<#A> // kotlinhax.shadowroutines/CompletableDeferred|CompletableDeferred(0:0){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> kotlinhax.shadowroutines/CompletableDeferred(kotlinhax.shadowroutines/Job? = ...): kotlinhax.shadowroutines/CompletableDeferred<#A> // kotlinhax.shadowroutines/CompletableDeferred|CompletableDeferred(kotlinhax.shadowroutines.Job?){0§<kotlin.Any?>}[0]
final fun <#A: kotlin/Any?> kotlinhax.shadowroutines/async(kotlin.coroutines/CoroutineContext = ..., kotlinhax.shadowroutines/CoroutineStart = ..., kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines/CoroutineScope, #A>): kotlinhax.shadowroutines/Deferred<#A> // kotlinhax.shadowroutines/async|async(kotlin.coroutines.CoroutineContext;kotlinhax.shadowroutines.CoroutineStart;kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.CoroutineScope,0:0>){0§<kotlin.Any?>}[0]
final fun kotlinhax.shadowroutines.channels/consumesAll(kotlin/Array<out kotlinhax.shadowroutines.channels/ReceiveChannel<*>>...): kotlin/Function1<kotlin/Throwable?, kotlin/Unit> // kotlinhax.shadowroutines.channels/consumesAll|consumesAll(kotlin.Array<out|kotlinhax.shadowroutines.channels.ReceiveChannel<*>>...){}[0]
final fun kotlinhax.shadowroutines.sync/Mutex(kotlin/Boolean = ...): kotlinhax.shadowroutines.sync/Mutex // kotlinhax.shadowroutines.sync/Mutex|Mutex(kotlin.Boolean){}[0]
final fun kotlinhax.shadowroutines.sync/Semaphore(kotlin/Int, kotlin/Int = ...): kotlinhax.shadowroutines.sync/Semaphore // kotlinhax.shadowroutines.sync/Semaphore|Semaphore(kotlin.Int;kotlin.Int){}[0]
final fun kotlinhax.shadowroutines/CancellationException(kotlin/String?, kotlin/Throwable?): kotlin.coroutines.cancellation/CancellationException // kotlinhax.shadowroutines/CancellationException|CancellationException(kotlin.String?;kotlin.Throwable?){}[0]
final fun kotlinhax.shadowroutines/CoroutineScope(kotlin.coroutines/CoroutineContext): kotlinhax.shadowroutines/CoroutineScope // kotlinhax.shadowroutines/CoroutineScope|CoroutineScope(kotlin.coroutines.CoroutineContext){}[0]
final fun kotlinhax.shadowroutines/Job(kotlinhax.shadowroutines/Job? = ...): kotlinhax.shadowroutines/CompletableJob // kotlinhax.shadowroutines/Job|Job(kotlinhax.shadowroutines.Job?){}[0]
final fun kotlinhax.shadowroutines/Job0(kotlinhax.shadowroutines/Job? = ...): kotlinhax.shadowroutines/Job // kotlinhax.shadowroutines/Job0|Job0(kotlinhax.shadowroutines.Job?){}[0]
final fun kotlinhax.shadowroutines/MainScope(): kotlinhax.shadowroutines/CoroutineScope // kotlinhax.shadowroutines/MainScope|MainScope(){}[0]
final fun kotlinhax.shadowroutines/SupervisorJob(kotlinhax.shadowroutines/Job? = ...): kotlinhax.shadowroutines/CompletableJob // kotlinhax.shadowroutines/SupervisorJob|SupervisorJob(kotlinhax.shadowroutines.Job?){}[0]
final fun kotlinhax.shadowroutines/SupervisorJob0(kotlinhax.shadowroutines/Job? = ...): kotlinhax.shadowroutines/Job // kotlinhax.shadowroutines/SupervisorJob0|SupervisorJob0(kotlinhax.shadowroutines.Job?){}[0]
final fun kotlinhax.shadowroutines/handleCoroutineException(kotlin.coroutines/CoroutineContext, kotlin/Throwable) // kotlinhax.shadowroutines/handleCoroutineException|handleCoroutineException(kotlin.coroutines.CoroutineContext;kotlin.Throwable){}[0]
final fun kotlinhax.shadowroutines/launch(kotlin.coroutines/CoroutineContext = ..., kotlinhax.shadowroutines/CoroutineStart = ..., kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines/CoroutineScope, kotlin/Unit>): kotlinhax.shadowroutines/Job // kotlinhax.shadowroutines/launch|launch(kotlin.coroutines.CoroutineContext;kotlinhax.shadowroutines.CoroutineStart;kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.CoroutineScope,kotlin.Unit>){}[0]
final inline fun <#A: kotlin/Any?, #B: kotlin/Any> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/mapNotNull(crossinline kotlin.coroutines/SuspendFunction1<#A, #B?>): kotlinhax.shadowroutines.flow/Flow<#B> // kotlinhax.shadowroutines.flow/mapNotNull|mapNotNull@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,0:1?>){0§<kotlin.Any?>;1§<kotlin.Any>}[0]
final inline fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.channels/BroadcastChannel<#A>).kotlinhax.shadowroutines.channels/consume(kotlin/Function1<kotlinhax.shadowroutines.channels/ReceiveChannel<#A>, #B>): #B // kotlinhax.shadowroutines.channels/consume|consume@kotlinhax.shadowroutines.channels.BroadcastChannel<0:0>(kotlin.Function1<kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final inline fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/consume(kotlin/Function1<kotlinhax.shadowroutines.channels/ReceiveChannel<#A>, #B>): #B // kotlinhax.shadowroutines.channels/consume|consume@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlin.Function1<kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final inline fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/flatMapLatest(crossinline kotlin.coroutines/SuspendFunction1<#A, kotlinhax.shadowroutines.flow/Flow<#B>>): kotlinhax.shadowroutines.flow/Flow<#B> // kotlinhax.shadowroutines.flow/flatMapLatest|flatMapLatest@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,kotlinhax.shadowroutines.flow.Flow<0:1>>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final inline fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/map(crossinline kotlin.coroutines/SuspendFunction1<#A, #B>): kotlinhax.shadowroutines.flow/Flow<#B> // kotlinhax.shadowroutines.flow/map|map@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final inline fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/transform(crossinline kotlin.coroutines/SuspendFunction2<kotlinhax.shadowroutines.flow/FlowCollector<#B>, #A, kotlin/Unit>): kotlinhax.shadowroutines.flow/Flow<#B> // kotlinhax.shadowroutines.flow/transform|transform@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction2<kotlinhax.shadowroutines.flow.FlowCollector<0:1>,0:0,kotlin.Unit>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final inline fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/unsafeTransform(crossinline kotlin.coroutines/SuspendFunction2<kotlinhax.shadowroutines.flow/FlowCollector<#B>, #A, kotlin/Unit>): kotlinhax.shadowroutines.flow/Flow<#B> // kotlinhax.shadowroutines.flow/unsafeTransform|unsafeTransform@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction2<kotlinhax.shadowroutines.flow.FlowCollector<0:1>,0:0,kotlin.Unit>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ChannelResult<#A>).kotlinhax.shadowroutines.channels/getOrElse(kotlin/Function1<kotlin/Throwable?, #A>): #A // kotlinhax.shadowroutines.channels/getOrElse|getOrElse@kotlinhax.shadowroutines.channels.ChannelResult<0:0>(kotlin.Function1<kotlin.Throwable?,0:0>){0§<kotlin.Any?>}[0]
final inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ChannelResult<#A>).kotlinhax.shadowroutines.channels/onClosed(kotlin/Function1<kotlin/Throwable?, kotlin/Unit>): kotlinhax.shadowroutines.channels/ChannelResult<#A> // kotlinhax.shadowroutines.channels/onClosed|onClosed@kotlinhax.shadowroutines.channels.ChannelResult<0:0>(kotlin.Function1<kotlin.Throwable?,kotlin.Unit>){0§<kotlin.Any?>}[0]
final inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ChannelResult<#A>).kotlinhax.shadowroutines.channels/onFailure(kotlin/Function1<kotlin/Throwable?, kotlin/Unit>): kotlinhax.shadowroutines.channels/ChannelResult<#A> // kotlinhax.shadowroutines.channels/onFailure|onFailure@kotlinhax.shadowroutines.channels.ChannelResult<0:0>(kotlin.Function1<kotlin.Throwable?,kotlin.Unit>){0§<kotlin.Any?>}[0]
final inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ChannelResult<#A>).kotlinhax.shadowroutines.channels/onSuccess(kotlin/Function1<#A, kotlin/Unit>): kotlinhax.shadowroutines.channels/ChannelResult<#A> // kotlinhax.shadowroutines.channels/onSuccess|onSuccess@kotlinhax.shadowroutines.channels.ChannelResult<0:0>(kotlin.Function1<0:0,kotlin.Unit>){0§<kotlin.Any?>}[0]
final inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/filter(crossinline kotlin.coroutines/SuspendFunction1<#A, kotlin/Boolean>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/filter|filter@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/filterNot(crossinline kotlin.coroutines/SuspendFunction1<#A, kotlin/Boolean>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/filterNot|filterNot@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/MutableStateFlow<#A>).kotlinhax.shadowroutines.flow/getAndUpdate(kotlin/Function1<#A, #A>): #A // kotlinhax.shadowroutines.flow/getAndUpdate|getAndUpdate@kotlinhax.shadowroutines.flow.MutableStateFlow<0:0>(kotlin.Function1<0:0,0:0>){0§<kotlin.Any?>}[0]
final inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/MutableStateFlow<#A>).kotlinhax.shadowroutines.flow/update(kotlin/Function1<#A, #A>) // kotlinhax.shadowroutines.flow/update|update@kotlinhax.shadowroutines.flow.MutableStateFlow<0:0>(kotlin.Function1<0:0,0:0>){0§<kotlin.Any?>}[0]
final inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/MutableStateFlow<#A>).kotlinhax.shadowroutines.flow/updateAndGet(kotlin/Function1<#A, #A>): #A // kotlinhax.shadowroutines.flow/updateAndGet|updateAndGet@kotlinhax.shadowroutines.flow.MutableStateFlow<0:0>(kotlin.Function1<0:0,0:0>){0§<kotlin.Any?>}[0]
final inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/SharedFlow<#A>).kotlinhax.shadowroutines.flow/catch(noinline kotlin.coroutines/SuspendFunction2<kotlinhax.shadowroutines.flow/FlowCollector<#A>, kotlin/Throwable, kotlin/Unit>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/catch|catch@kotlinhax.shadowroutines.flow.SharedFlow<0:0>(kotlin.coroutines.SuspendFunction2<kotlinhax.shadowroutines.flow.FlowCollector<0:0>,kotlin.Throwable,kotlin.Unit>){0§<kotlin.Any?>}[0]
final inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/SharedFlow<#A>).kotlinhax.shadowroutines.flow/retry(kotlin/Long = ..., noinline kotlin.coroutines/SuspendFunction1<kotlin/Throwable, kotlin/Boolean> = ...): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/retry|retry@kotlinhax.shadowroutines.flow.SharedFlow<0:0>(kotlin.Long;kotlin.coroutines.SuspendFunction1<kotlin.Throwable,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/SharedFlow<#A>).kotlinhax.shadowroutines.flow/retryWhen(noinline kotlin.coroutines/SuspendFunction3<kotlinhax.shadowroutines.flow/FlowCollector<#A>, kotlin/Throwable, kotlin/Long, kotlin/Boolean>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/retryWhen|retryWhen@kotlinhax.shadowroutines.flow.SharedFlow<0:0>(kotlin.coroutines.SuspendFunction3<kotlinhax.shadowroutines.flow.FlowCollector<0:0>,kotlin.Throwable,kotlin.Long,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final inline fun <#A: kotlin/Any?> kotlinhax.shadowroutines.flow.internal/unsafeFlow(crossinline kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines.flow/FlowCollector<#A>, kotlin/Unit>): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow.internal/unsafeFlow|unsafeFlow(kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.flow.FlowCollector<0:0>,kotlin.Unit>){0§<kotlin.Any?>}[0]
final inline fun <#A: reified kotlin/Any?, #B: kotlin/Any?> kotlinhax.shadowroutines.flow/combine(kotlin.collections/Iterable<kotlinhax.shadowroutines.flow/Flow<#A>>, crossinline kotlin.coroutines/SuspendFunction1<kotlin/Array<#A>, #B>): kotlinhax.shadowroutines.flow/Flow<#B> // kotlinhax.shadowroutines.flow/combine|combine(kotlin.collections.Iterable<kotlinhax.shadowroutines.flow.Flow<0:0>>;kotlin.coroutines.SuspendFunction1<kotlin.Array<0:0>,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final inline fun <#A: reified kotlin/Any?, #B: kotlin/Any?> kotlinhax.shadowroutines.flow/combine(kotlin/Array<out kotlinhax.shadowroutines.flow/Flow<#A>>..., crossinline kotlin.coroutines/SuspendFunction1<kotlin/Array<#A>, #B>): kotlinhax.shadowroutines.flow/Flow<#B> // kotlinhax.shadowroutines.flow/combine|combine(kotlin.Array<out|kotlinhax.shadowroutines.flow.Flow<0:0>>...;kotlin.coroutines.SuspendFunction1<kotlin.Array<0:0>,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final inline fun <#A: reified kotlin/Any?, #B: kotlin/Any?> kotlinhax.shadowroutines.flow/combineTransform(kotlin.collections/Iterable<kotlinhax.shadowroutines.flow/Flow<#A>>, crossinline kotlin.coroutines/SuspendFunction2<kotlinhax.shadowroutines.flow/FlowCollector<#B>, kotlin/Array<#A>, kotlin/Unit>): kotlinhax.shadowroutines.flow/Flow<#B> // kotlinhax.shadowroutines.flow/combineTransform|combineTransform(kotlin.collections.Iterable<kotlinhax.shadowroutines.flow.Flow<0:0>>;kotlin.coroutines.SuspendFunction2<kotlinhax.shadowroutines.flow.FlowCollector<0:1>,kotlin.Array<0:0>,kotlin.Unit>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final inline fun <#A: reified kotlin/Any?, #B: kotlin/Any?> kotlinhax.shadowroutines.flow/combineTransform(kotlin/Array<out kotlinhax.shadowroutines.flow/Flow<#A>>..., crossinline kotlin.coroutines/SuspendFunction2<kotlinhax.shadowroutines.flow/FlowCollector<#B>, kotlin/Array<#A>, kotlin/Unit>): kotlinhax.shadowroutines.flow/Flow<#B> // kotlinhax.shadowroutines.flow/combineTransform|combineTransform(kotlin.Array<out|kotlinhax.shadowroutines.flow.Flow<0:0>>...;kotlin.coroutines.SuspendFunction2<kotlinhax.shadowroutines.flow.FlowCollector<0:1>,kotlin.Array<0:0>,kotlin.Unit>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final inline fun <#A: reified kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<*>).kotlinhax.shadowroutines.flow/filterIsInstance(): kotlinhax.shadowroutines.flow/Flow<#A> // kotlinhax.shadowroutines.flow/filterIsInstance|filterIsInstance@kotlinhax.shadowroutines.flow.Flow<*>(){0§<kotlin.Any?>}[0]
final inline fun kotlinhax.shadowroutines.flow.internal/checkIndexOverflow(kotlin/Int): kotlin/Int // kotlinhax.shadowroutines.flow.internal/checkIndexOverflow|checkIndexOverflow(kotlin.Int){}[0]
final inline fun kotlinhax.shadowroutines/CoroutineExceptionHandler(crossinline kotlin/Function2<kotlin.coroutines/CoroutineContext, kotlin/Throwable, kotlin/Unit>): kotlinhax.shadowroutines/CoroutineExceptionHandler // kotlinhax.shadowroutines/CoroutineExceptionHandler|CoroutineExceptionHandler(kotlin.Function2<kotlin.coroutines.CoroutineContext,kotlin.Throwable,kotlin.Unit>){}[0]
final inline fun kotlinhax.shadowroutines/Runnable(crossinline kotlin/Function0<kotlin/Unit>): kotlinhax.shadowroutines/Runnable // kotlinhax.shadowroutines/Runnable|Runnable(kotlin.Function0<kotlin.Unit>){}[0]
final suspend fun (kotlin.collections/Collection<kotlinhax.shadowroutines/Job>).kotlinhax.shadowroutines/joinAll() // kotlinhax.shadowroutines/joinAll|joinAll@kotlin.collections.Collection<kotlinhax.shadowroutines.Job>(){}[0]
final suspend fun (kotlinhax.shadowroutines.channels/ProducerScope<*>).kotlinhax.shadowroutines.channels/awaitClose(kotlin/Function0<kotlin/Unit> = ...) // kotlinhax.shadowroutines.channels/awaitClose|awaitClose@kotlinhax.shadowroutines.channels.ProducerScope<*>(kotlin.Function0<kotlin.Unit>){}[0]
final suspend fun (kotlinhax.shadowroutines.flow/Flow<*>).kotlinhax.shadowroutines.flow/collect() // kotlinhax.shadowroutines.flow/collect|collect@kotlinhax.shadowroutines.flow.Flow<*>(){}[0]
final suspend fun (kotlinhax.shadowroutines/Job).kotlinhax.shadowroutines/cancelAndJoin() // kotlinhax.shadowroutines/cancelAndJoin|cancelAndJoin@kotlinhax.shadowroutines.Job(){}[0]
final suspend fun <#A: kotlin/Any, #B: kotlin.collections/MutableCollection<in #A>> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A?>).kotlinhax.shadowroutines.channels/filterNotNullTo(#B): #B // kotlinhax.shadowroutines.channels/filterNotNullTo|filterNotNullTo@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0?>(0:1){0§<kotlin.Any>;1§<kotlin.collections.MutableCollection<in|0:0>>}[0]
final suspend fun <#A: kotlin/Any, #B: kotlinhax.shadowroutines.channels/SendChannel<#A>> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A?>).kotlinhax.shadowroutines.channels/filterNotNullTo(#B): #B // kotlinhax.shadowroutines.channels/filterNotNullTo|filterNotNullTo@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0?>(0:1){0§<kotlin.Any>;1§<kotlinhax.shadowroutines.channels.SendChannel<0:0>>}[0]
final suspend fun <#A: kotlin/Any> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/receiveOrNull(): #A? // kotlinhax.shadowroutines.channels/receiveOrNull|receiveOrNull@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(){0§<kotlin.Any>}[0]
final suspend fun <#A: kotlin/Any?, #B: #A> (kotlinhax.shadowroutines.flow/Flow<#B>).kotlinhax.shadowroutines.flow/reduce(kotlin.coroutines/SuspendFunction2<#A, #B, #A>): #A // kotlinhax.shadowroutines.flow/reduce|reduce@kotlinhax.shadowroutines.flow.Flow<0:1>(kotlin.coroutines.SuspendFunction2<0:0,0:1,0:0>){0§<kotlin.Any?>;1§<0:0>}[0]
final suspend fun <#A: kotlin/Any?, #B: kotlin.collections/MutableCollection<in #A>> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/toCollection(#B): #B // kotlinhax.shadowroutines.channels/toCollection|toCollection@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(0:1){0§<kotlin.Any?>;1§<kotlin.collections.MutableCollection<in|0:0>>}[0]
final suspend fun <#A: kotlin/Any?, #B: kotlin.collections/MutableCollection<in #A>> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/toCollection(#B): #B // kotlinhax.shadowroutines.flow/toCollection|toCollection@kotlinhax.shadowroutines.flow.Flow<0:0>(0:1){0§<kotlin.Any?>;1§<kotlin.collections.MutableCollection<in|0:0>>}[0]
final suspend fun <#A: kotlin/Any?, #B: kotlin/Any?, #C: kotlin.collections/MutableMap<in #A, in #B>> (kotlinhax.shadowroutines.channels/ReceiveChannel<kotlin/Pair<#A, #B>>).kotlinhax.shadowroutines.channels/toMap(#C): #C // kotlinhax.shadowroutines.channels/toMap|toMap@kotlinhax.shadowroutines.channels.ReceiveChannel<kotlin.Pair<0:0,0:1>>(0:2){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.collections.MutableMap<in|0:0,in|0:1>>}[0]
final suspend fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<kotlin/Pair<#A, #B>>).kotlinhax.shadowroutines.channels/toMap(): kotlin.collections/Map<#A, #B> // kotlinhax.shadowroutines.channels/toMap|toMap@kotlinhax.shadowroutines.channels.ReceiveChannel<kotlin.Pair<0:0,0:1>>(){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.flow/FlowCollector<#A>).kotlinhax.shadowroutines.flow.internal/combineInternal(kotlin/Array<out kotlinhax.shadowroutines.flow/Flow<#B>>, kotlin/Function0<kotlin/Array<#B?>?>, kotlin.coroutines/SuspendFunction2<kotlinhax.shadowroutines.flow/FlowCollector<#A>, kotlin/Array<#B>, kotlin/Unit>) // kotlinhax.shadowroutines.flow.internal/combineInternal|combineInternal@kotlinhax.shadowroutines.flow.FlowCollector<0:0>(kotlin.Array<out|kotlinhax.shadowroutines.flow.Flow<0:1>>;kotlin.Function0<kotlin.Array<0:1?>?>;kotlin.coroutines.SuspendFunction2<kotlinhax.shadowroutines.flow.FlowCollector<0:0>,kotlin.Array<0:1>,kotlin.Unit>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?, #B: kotlinhax.shadowroutines.channels/SendChannel<#A>> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/toChannel(#B): #B // kotlinhax.shadowroutines.channels/toChannel|toChannel@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(0:1){0§<kotlin.Any?>;1§<kotlinhax.shadowroutines.channels.SendChannel<0:0>>}[0]
final suspend fun <#A: kotlin/Any?> (kotlin.collections/Collection<kotlinhax.shadowroutines/Deferred<#A>>).kotlinhax.shadowroutines/awaitAll(): kotlin.collections/List<#A> // kotlinhax.shadowroutines/awaitAll|awaitAll@kotlin.collections.Collection<kotlinhax.shadowroutines.Deferred<0:0>>(){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/any(): kotlin/Boolean // kotlinhax.shadowroutines.channels/any|any@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/count(): kotlin/Int // kotlinhax.shadowroutines.channels/count|count@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/elementAt(kotlin/Int): #A // kotlinhax.shadowroutines.channels/elementAt|elementAt@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlin.Int){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/elementAtOrNull(kotlin/Int): #A? // kotlinhax.shadowroutines.channels/elementAtOrNull|elementAtOrNull@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlin.Int){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/first(): #A // kotlinhax.shadowroutines.channels/first|first@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/firstOrNull(): #A? // kotlinhax.shadowroutines.channels/firstOrNull|firstOrNull@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/indexOf(#A): kotlin/Int // kotlinhax.shadowroutines.channels/indexOf|indexOf@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(0:0){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/last(): #A // kotlinhax.shadowroutines.channels/last|last@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/lastIndexOf(#A): kotlin/Int // kotlinhax.shadowroutines.channels/lastIndexOf|lastIndexOf@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(0:0){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/lastOrNull(): #A? // kotlinhax.shadowroutines.channels/lastOrNull|lastOrNull@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/maxWith(kotlin/Comparator<in #A>): #A? // kotlinhax.shadowroutines.channels/maxWith|maxWith@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlin.Comparator<in|0:0>){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/minWith(kotlin/Comparator<in #A>): #A? // kotlinhax.shadowroutines.channels/minWith|minWith@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlin.Comparator<in|0:0>){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/none(): kotlin/Boolean // kotlinhax.shadowroutines.channels/none|none@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/single(): #A // kotlinhax.shadowroutines.channels/single|single@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/singleOrNull(): #A? // kotlinhax.shadowroutines.channels/singleOrNull|singleOrNull@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/toList(): kotlin.collections/List<#A> // kotlinhax.shadowroutines.channels/toList|toList@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/toMutableList(): kotlin.collections/MutableList<#A> // kotlinhax.shadowroutines.channels/toMutableList|toMutableList@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/toMutableSet(): kotlin.collections/MutableSet<#A> // kotlinhax.shadowroutines.channels/toMutableSet|toMutableSet@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/toSet(): kotlin.collections/Set<#A> // kotlinhax.shadowroutines.channels/toSet|toSet@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/all(kotlin.coroutines/SuspendFunction1<#A, kotlin/Boolean>): kotlin/Boolean // kotlinhax.shadowroutines.flow/all|all@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/any(kotlin.coroutines/SuspendFunction1<#A, kotlin/Boolean>): kotlin/Boolean // kotlinhax.shadowroutines.flow/any|any@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/collectLatest(kotlin.coroutines/SuspendFunction1<#A, kotlin/Unit>) // kotlinhax.shadowroutines.flow/collectLatest|collectLatest@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,kotlin.Unit>){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/count(): kotlin/Int // kotlinhax.shadowroutines.flow/count|count@kotlinhax.shadowroutines.flow.Flow<0:0>(){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/count(kotlin.coroutines/SuspendFunction1<#A, kotlin/Boolean>): kotlin/Int // kotlinhax.shadowroutines.flow/count|count@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/first(): #A // kotlinhax.shadowroutines.flow/first|first@kotlinhax.shadowroutines.flow.Flow<0:0>(){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/first(kotlin.coroutines/SuspendFunction1<#A, kotlin/Boolean>): #A // kotlinhax.shadowroutines.flow/first|first@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/firstOrNull(): #A? // kotlinhax.shadowroutines.flow/firstOrNull|firstOrNull@kotlinhax.shadowroutines.flow.Flow<0:0>(){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/firstOrNull(kotlin.coroutines/SuspendFunction1<#A, kotlin/Boolean>): #A? // kotlinhax.shadowroutines.flow/firstOrNull|firstOrNull@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/last(): #A // kotlinhax.shadowroutines.flow/last|last@kotlinhax.shadowroutines.flow.Flow<0:0>(){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/lastOrNull(): #A? // kotlinhax.shadowroutines.flow/lastOrNull|lastOrNull@kotlinhax.shadowroutines.flow.Flow<0:0>(){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/none(kotlin.coroutines/SuspendFunction1<#A, kotlin/Boolean>): kotlin/Boolean // kotlinhax.shadowroutines.flow/none|none@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,kotlin.Boolean>){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/single(): #A // kotlinhax.shadowroutines.flow/single|single@kotlinhax.shadowroutines.flow.Flow<0:0>(){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/singleOrNull(): #A? // kotlinhax.shadowroutines.flow/singleOrNull|singleOrNull@kotlinhax.shadowroutines.flow.Flow<0:0>(){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/stateIn(kotlinhax.shadowroutines/CoroutineScope): kotlinhax.shadowroutines.flow/StateFlow<#A> // kotlinhax.shadowroutines.flow/stateIn|stateIn@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlinhax.shadowroutines.CoroutineScope){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/toList(kotlin.collections/MutableList<#A> = ...): kotlin.collections/List<#A> // kotlinhax.shadowroutines.flow/toList|toList@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.collections.MutableList<0:0>){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/toSet(kotlin.collections/MutableSet<#A> = ...): kotlin.collections/Set<#A> // kotlinhax.shadowroutines.flow/toSet|toSet@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.collections.MutableSet<0:0>){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/FlowCollector<#A>).kotlinhax.shadowroutines.flow/emitAll(kotlinhax.shadowroutines.channels/ReceiveChannel<#A>) // kotlinhax.shadowroutines.flow/emitAll|emitAll@kotlinhax.shadowroutines.flow.FlowCollector<0:0>(kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/FlowCollector<#A>).kotlinhax.shadowroutines.flow/emitAll(kotlinhax.shadowroutines.flow/Flow<#A>) // kotlinhax.shadowroutines.flow/emitAll|emitAll@kotlinhax.shadowroutines.flow.FlowCollector<0:0>(kotlinhax.shadowroutines.flow.Flow<0:0>){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> kotlinhax.shadowroutines/awaitAll(kotlin/Array<out kotlinhax.shadowroutines/Deferred<#A>>...): kotlin.collections/List<#A> // kotlinhax.shadowroutines/awaitAll|awaitAll(kotlin.Array<out|kotlinhax.shadowroutines.Deferred<0:0>>...){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> kotlinhax.shadowroutines/coroutineScope(kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines/CoroutineScope, #A>): #A // kotlinhax.shadowroutines/coroutineScope|coroutineScope(kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.CoroutineScope,0:0>){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> kotlinhax.shadowroutines/supervisorScope(kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines/CoroutineScope, #A>): #A // kotlinhax.shadowroutines/supervisorScope|supervisorScope(kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.CoroutineScope,0:0>){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> kotlinhax.shadowroutines/withContext(kotlin.coroutines/CoroutineContext, kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines/CoroutineScope, #A>): #A // kotlinhax.shadowroutines/withContext|withContext(kotlin.coroutines.CoroutineContext;kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.CoroutineScope,0:0>){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> kotlinhax.shadowroutines/withTimeout(kotlin.time/Duration, kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines/CoroutineScope, #A>): #A // kotlinhax.shadowroutines/withTimeout|withTimeout(kotlin.time.Duration;kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.CoroutineScope,0:0>){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> kotlinhax.shadowroutines/withTimeout(kotlin/Long, kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines/CoroutineScope, #A>): #A // kotlinhax.shadowroutines/withTimeout|withTimeout(kotlin.Long;kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.CoroutineScope,0:0>){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> kotlinhax.shadowroutines/withTimeoutOrNull(kotlin.time/Duration, kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines/CoroutineScope, #A>): #A? // kotlinhax.shadowroutines/withTimeoutOrNull|withTimeoutOrNull(kotlin.time.Duration;kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.CoroutineScope,0:0>){0§<kotlin.Any?>}[0]
final suspend fun <#A: kotlin/Any?> kotlinhax.shadowroutines/withTimeoutOrNull(kotlin/Long, kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines/CoroutineScope, #A>): #A? // kotlinhax.shadowroutines/withTimeoutOrNull|withTimeoutOrNull(kotlin.Long;kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.CoroutineScope,0:0>){0§<kotlin.Any?>}[0]
final suspend fun kotlinhax.shadowroutines/awaitCancellation(): kotlin/Nothing // kotlinhax.shadowroutines/awaitCancellation|awaitCancellation(){}[0]
final suspend fun kotlinhax.shadowroutines/delay(kotlin.time/Duration) // kotlinhax.shadowroutines/delay|delay(kotlin.time.Duration){}[0]
final suspend fun kotlinhax.shadowroutines/delay(kotlin/Long) // kotlinhax.shadowroutines/delay|delay(kotlin.Long){}[0]
final suspend fun kotlinhax.shadowroutines/joinAll(kotlin/Array<out kotlinhax.shadowroutines/Job>...) // kotlinhax.shadowroutines/joinAll|joinAll(kotlin.Array<out|kotlinhax.shadowroutines.Job>...){}[0]
final suspend fun kotlinhax.shadowroutines/yield() // kotlinhax.shadowroutines/yield|yield(){}[0]
final suspend inline fun <#A: kotlin/Any?, #B: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/fold(#B, crossinline kotlin.coroutines/SuspendFunction2<#B, #A, #B>): #B // kotlinhax.shadowroutines.flow/fold|fold@kotlinhax.shadowroutines.flow.Flow<0:0>(0:1;kotlin.coroutines.SuspendFunction2<0:1,0:0,0:1>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
final suspend inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/BroadcastChannel<#A>).kotlinhax.shadowroutines.channels/consumeEach(kotlin/Function1<#A, kotlin/Unit>) // kotlinhax.shadowroutines.channels/consumeEach|consumeEach@kotlinhax.shadowroutines.channels.BroadcastChannel<0:0>(kotlin.Function1<0:0,kotlin.Unit>){0§<kotlin.Any?>}[0]
final suspend inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/ReceiveChannel<#A>).kotlinhax.shadowroutines.channels/consumeEach(kotlin/Function1<#A, kotlin/Unit>) // kotlinhax.shadowroutines.channels/consumeEach|consumeEach@kotlinhax.shadowroutines.channels.ReceiveChannel<0:0>(kotlin.Function1<0:0,kotlin.Unit>){0§<kotlin.Any?>}[0]
final suspend inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/collect(crossinline kotlin.coroutines/SuspendFunction1<#A, kotlin/Unit>) // kotlinhax.shadowroutines.flow/collect|collect@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction1<0:0,kotlin.Unit>){0§<kotlin.Any?>}[0]
final suspend inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/Flow<#A>).kotlinhax.shadowroutines.flow/collectIndexed(crossinline kotlin.coroutines/SuspendFunction2<kotlin/Int, #A, kotlin/Unit>) // kotlinhax.shadowroutines.flow/collectIndexed|collectIndexed@kotlinhax.shadowroutines.flow.Flow<0:0>(kotlin.coroutines.SuspendFunction2<kotlin.Int,0:0,kotlin.Unit>){0§<kotlin.Any?>}[0]
final suspend inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/SharedFlow<#A>).kotlinhax.shadowroutines.flow/count(): kotlin/Int // kotlinhax.shadowroutines.flow/count|count@kotlinhax.shadowroutines.flow.SharedFlow<0:0>(){0§<kotlin.Any?>}[0]
final suspend inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/SharedFlow<#A>).kotlinhax.shadowroutines.flow/toList(): kotlin.collections/List<#A> // kotlinhax.shadowroutines.flow/toList|toList@kotlinhax.shadowroutines.flow.SharedFlow<0:0>(){0§<kotlin.Any?>}[0]
final suspend inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/SharedFlow<#A>).kotlinhax.shadowroutines.flow/toList(kotlin.collections/MutableList<#A>): kotlin/Nothing // kotlinhax.shadowroutines.flow/toList|toList@kotlinhax.shadowroutines.flow.SharedFlow<0:0>(kotlin.collections.MutableList<0:0>){0§<kotlin.Any?>}[0]
final suspend inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/SharedFlow<#A>).kotlinhax.shadowroutines.flow/toSet(): kotlin.collections/Set<#A> // kotlinhax.shadowroutines.flow/toSet|toSet@kotlinhax.shadowroutines.flow.SharedFlow<0:0>(){0§<kotlin.Any?>}[0]
final suspend inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.flow/SharedFlow<#A>).kotlinhax.shadowroutines.flow/toSet(kotlin.collections/MutableSet<#A>): kotlin/Nothing // kotlinhax.shadowroutines.flow/toSet|toSet@kotlinhax.shadowroutines.flow.SharedFlow<0:0>(kotlin.collections.MutableSet<0:0>){0§<kotlin.Any?>}[0]
final suspend inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.sync/Mutex).kotlinhax.shadowroutines.sync/withLock(kotlin/Any? = ..., kotlin/Function0<#A>): #A // kotlinhax.shadowroutines.sync/withLock|withLock@kotlinhax.shadowroutines.sync.Mutex(kotlin.Any?;kotlin.Function0<0:0>){0§<kotlin.Any?>}[0]
final suspend inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.sync/Semaphore).kotlinhax.shadowroutines.sync/withPermit(kotlin/Function0<#A>): #A // kotlinhax.shadowroutines.sync/withPermit|withPermit@kotlinhax.shadowroutines.sync.Semaphore(kotlin.Function0<0:0>){0§<kotlin.Any?>}[0]
final suspend inline fun <#A: kotlin/Any?> (kotlinhax.shadowroutines/CoroutineDispatcher).kotlinhax.shadowroutines/invoke(noinline kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines/CoroutineScope, #A>): #A // kotlinhax.shadowroutines/invoke|invoke@kotlinhax.shadowroutines.CoroutineDispatcher(kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.CoroutineScope,0:0>){0§<kotlin.Any?>}[0]
final suspend inline fun <#A: kotlin/Any?> kotlinhax.shadowroutines.selects/select(crossinline kotlin/Function1<kotlinhax.shadowroutines.selects/SelectBuilder<#A>, kotlin/Unit>): #A // kotlinhax.shadowroutines.selects/select|select(kotlin.Function1<kotlinhax.shadowroutines.selects.SelectBuilder<0:0>,kotlin.Unit>){0§<kotlin.Any?>}[0]
final suspend inline fun <#A: kotlin/Any?> kotlinhax.shadowroutines.selects/selectOld(crossinline kotlin/Function1<kotlinhax.shadowroutines.selects/SelectBuilder<#A>, kotlin/Unit>): #A // kotlinhax.shadowroutines.selects/selectOld|selectOld(kotlin.Function1<kotlinhax.shadowroutines.selects.SelectBuilder<0:0>,kotlin.Unit>){0§<kotlin.Any?>}[0]
final suspend inline fun <#A: kotlin/Any?> kotlinhax.shadowroutines.selects/selectUnbiased(crossinline kotlin/Function1<kotlinhax.shadowroutines.selects/SelectBuilder<#A>, kotlin/Unit>): #A // kotlinhax.shadowroutines.selects/selectUnbiased|selectUnbiased(kotlin.Function1<kotlinhax.shadowroutines.selects.SelectBuilder<0:0>,kotlin.Unit>){0§<kotlin.Any?>}[0]
final suspend inline fun <#A: kotlin/Any?> kotlinhax.shadowroutines.selects/selectUnbiasedOld(crossinline kotlin/Function1<kotlinhax.shadowroutines.selects/SelectBuilder<#A>, kotlin/Unit>): #A // kotlinhax.shadowroutines.selects/selectUnbiasedOld|selectUnbiasedOld(kotlin.Function1<kotlinhax.shadowroutines.selects.SelectBuilder<0:0>,kotlin.Unit>){0§<kotlin.Any?>}[0]
final suspend inline fun <#A: kotlin/Any?> kotlinhax.shadowroutines/suspendCancellableCoroutine(crossinline kotlin/Function1<kotlinhax.shadowroutines/CancellableContinuation<#A>, kotlin/Unit>): #A // kotlinhax.shadowroutines/suspendCancellableCoroutine|suspendCancellableCoroutine(kotlin.Function1<kotlinhax.shadowroutines.CancellableContinuation<0:0>,kotlin.Unit>){0§<kotlin.Any?>}[0]
final suspend inline fun kotlinhax.shadowroutines.selects/whileSelect(crossinline kotlin/Function1<kotlinhax.shadowroutines.selects/SelectBuilder<kotlin/Boolean>, kotlin/Unit>) // kotlinhax.shadowroutines.selects/whileSelect|whileSelect(kotlin.Function1<kotlinhax.shadowroutines.selects.SelectBuilder<kotlin.Boolean>,kotlin.Unit>){}[0]
final suspend inline fun kotlinhax.shadowroutines/currentCoroutineContext(): kotlin.coroutines/CoroutineContext // kotlinhax.shadowroutines/currentCoroutineContext|currentCoroutineContext(){}[0]

// Targets: [native]
final val kotlinhax.shadowroutines/IO // kotlinhax.shadowroutines/IO|@kotlinhax.shadowroutines.Dispatchers{}IO[0]
    final fun (kotlinhax.shadowroutines/Dispatchers).<get-IO>(): kotlinhax.shadowroutines/CoroutineDispatcher // kotlinhax.shadowroutines/IO.<get-IO>|<get-IO>@kotlinhax.shadowroutines.Dispatchers(){}[0]

// Targets: [native]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/SendChannel<#A>).kotlinhax.shadowroutines.channels/sendBlocking(#A) // kotlinhax.shadowroutines.channels/sendBlocking|sendBlocking@kotlinhax.shadowroutines.channels.SendChannel<0:0>(0:0){0§<kotlin.Any?>}[0]

// Targets: [native]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines.channels/SendChannel<#A>).kotlinhax.shadowroutines.channels/trySendBlocking(#A): kotlinhax.shadowroutines.channels/ChannelResult<kotlin/Unit> // kotlinhax.shadowroutines.channels/trySendBlocking|trySendBlocking@kotlinhax.shadowroutines.channels.SendChannel<0:0>(0:0){0§<kotlin.Any?>}[0]

// Targets: [native]
final fun <#A: kotlin/Any?> kotlinhax.shadowroutines/runBlocking(kotlin.coroutines/CoroutineContext = ..., kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines/CoroutineScope, #A>): #A // kotlinhax.shadowroutines/runBlocking|runBlocking(kotlin.coroutines.CoroutineContext;kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.CoroutineScope,0:0>){0§<kotlin.Any?>}[0]

// Targets: [native]
final fun kotlinhax.shadowroutines/newFixedThreadPoolContext(kotlin/Int, kotlin/String): kotlinhax.shadowroutines/CloseableCoroutineDispatcher // kotlinhax.shadowroutines/newFixedThreadPoolContext|newFixedThreadPoolContext(kotlin.Int;kotlin.String){}[0]

// Targets: [native]
final fun kotlinhax.shadowroutines/newSingleThreadContext(kotlin/String): kotlinhax.shadowroutines/CloseableCoroutineDispatcher // kotlinhax.shadowroutines/newSingleThreadContext|newSingleThreadContext(kotlin.String){}[0]

// Targets: [js]
final fun (org.w3c.dom/Window).kotlinhax.shadowroutines/asCoroutineDispatcher(): kotlinhax.shadowroutines/CoroutineDispatcher // kotlinhax.shadowroutines/asCoroutineDispatcher|asCoroutineDispatcher@org.w3c.dom.Window(){}[0]

// Targets: [js]
final fun <#A: kotlin/Any?> (kotlin.js/Promise<#A>).kotlinhax.shadowroutines/asDeferred(): kotlinhax.shadowroutines/Deferred<#A> // kotlinhax.shadowroutines/asDeferred|asDeferred@kotlin.js.Promise<0:0>(){0§<kotlin.Any?>}[0]

// Targets: [js]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines/CoroutineScope).kotlinhax.shadowroutines/promise(kotlin.coroutines/CoroutineContext = ..., kotlinhax.shadowroutines/CoroutineStart = ..., kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines/CoroutineScope, #A>): kotlin.js/Promise<#A> // kotlinhax.shadowroutines/promise|promise@kotlinhax.shadowroutines.CoroutineScope(kotlin.coroutines.CoroutineContext;kotlinhax.shadowroutines.CoroutineStart;kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.CoroutineScope,0:0>){0§<kotlin.Any?>}[0]

// Targets: [js]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines/Deferred<#A>).kotlinhax.shadowroutines/asPromise(): kotlin.js/Promise<#A> // kotlinhax.shadowroutines/asPromise|asPromise@kotlinhax.shadowroutines.Deferred<0:0>(){0§<kotlin.Any?>}[0]

// Targets: [js]
final suspend fun (org.w3c.dom/Window).kotlinhax.shadowroutines/awaitAnimationFrame(): kotlin/Double // kotlinhax.shadowroutines/awaitAnimationFrame|awaitAnimationFrame@org.w3c.dom.Window(){}[0]

// Targets: [js]
final suspend fun <#A: kotlin/Any?> (kotlin.js/Promise<#A>).kotlinhax.shadowroutines/await(): #A // kotlinhax.shadowroutines/await|await@kotlin.js.Promise<0:0>(){0§<kotlin.Any?>}[0]

// Targets: [wasmJs]
final fun <#A: kotlin/Any?> (kotlin.js/Promise<kotlin.js/JsAny?>).kotlinhax.shadowroutines/asDeferred(): kotlinhax.shadowroutines/Deferred<#A> // kotlinhax.shadowroutines/asDeferred|asDeferred@kotlin.js.Promise<kotlin.js.JsAny?>(){0§<kotlin.Any?>}[0]

// Targets: [wasmJs]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines/CoroutineScope).kotlinhax.shadowroutines/promise(kotlin.coroutines/CoroutineContext = ..., kotlinhax.shadowroutines/CoroutineStart = ..., kotlin.coroutines/SuspendFunction1<kotlinhax.shadowroutines/CoroutineScope, #A>): kotlin.js/Promise<kotlin.js/JsAny?> // kotlinhax.shadowroutines/promise|promise@kotlinhax.shadowroutines.CoroutineScope(kotlin.coroutines.CoroutineContext;kotlinhax.shadowroutines.CoroutineStart;kotlin.coroutines.SuspendFunction1<kotlinhax.shadowroutines.CoroutineScope,0:0>){0§<kotlin.Any?>}[0]

// Targets: [wasmJs]
final fun <#A: kotlin/Any?> (kotlinhax.shadowroutines/Deferred<#A>).kotlinhax.shadowroutines/asPromise(): kotlin.js/Promise<kotlin.js/JsAny?> // kotlinhax.shadowroutines/asPromise|asPromise@kotlinhax.shadowroutines.Deferred<0:0>(){0§<kotlin.Any?>}[0]

// Targets: [wasmJs]
final suspend fun <#A: kotlin/Any?> (kotlin.js/Promise<kotlin.js/JsAny?>).kotlinhax.shadowroutines/await(): #A // kotlinhax.shadowroutines/await|await@kotlin.js.Promise<kotlin.js.JsAny?>(){0§<kotlin.Any?>}[0]
